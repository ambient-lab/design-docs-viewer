# A1 プロジェクト管理システム バッチ設計書 (Next.js Cron Jobs)

## 目次
- [1. 仕様概要](#1-仕様概要)
- [2. 設計概要](#2-設計概要)
- [3. BA1060101 プロジェクト一括出力](#3-ba1060101-プロジェクト一括出力)
- [4. BA1070101 プロジェクト一括登録](#4-ba1070101-プロジェクト一括登録)
- [5. 共通実装パターン](#5-共通実装パターン)
- [6. テーブル移送表](#6-テーブル移送表)

---

## 1. 仕様概要

### 1.1 目的
本バッチ設計書は、プロジェクト管理システム(A1)におけるNext.js環境でのバッチ処理(Cron Jobs)の設計仕様を定義する。

### 1.2 対象バッチ一覧

| バッチID | バッチ名 | 処理方式 | 実行タイミング | 概要 |
|---------|---------|---------|--------------|-----|
| BA1060101 | プロジェクト一括出力 | API Route + Cron | オンデマンド/日次 | 指定期間内のプロジェクト情報をCSV出力 |
| BA1070101 | プロジェクト一括登録 | API Route + Cron | オンデマンド/日次 | CSVファイルからプロジェクト一括登録 |

### 1.3 バッチ実行環境

```yaml
実行環境:
  フレームワーク: Next.js 14+ (App Router)
  Runtime: Node.js 18+
  パッケージマネージャー: npm/pnpm

実行モード:
  オンデマンド: Web画面からのAPI呼び出し
  スケジュール: Vercel Cron / node-cron による自動実行

ログ出力:
  レベル: info (エラー時はerror)
  出力先: コンソール + ファイル(/logs/jobs/{job_id}/{yyyyMMdd}/)
  ローテーション: 日次、30日保管

デプロイ先:
  - Vercel (推奨): Vercel Cron使用
  - セルフホスト: node-cron使用
```

---

## 2. 設計概要

### 2.1 Next.js Cron Jobアーキテクチャ

```
┌─────────────────────────────────────────────────────┐
│           Cron Trigger / Manual Request             │
│  - Vercel Cron (vercel.json)                        │
│  - node-cron (セルフホスト)                           │
│  - Web画面からのAPI呼び出し                            │
└──────────────────┬──────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────┐
│        API Route Handler                            │
│  app/api/jobs/[job-name]/route.ts                   │
│  - パラメータ検証                                      │
│  - 認証・認可チェック                                   │
│  - ジョブ実行制御                                      │
└──────────────────┬──────────────────────────────────┘
                   │
        ┌──────────┴──────────┐
        │                     │
        ▼                     ▼
┌───────────────┐    ┌────────────────┐
│  CSV Export   │    │  CSV Import    │
│  Job Handler  │    │  Job Handler   │
│               │    │                │
│ ┌───────────┐ │    │ ┌────────────┐ │
│ │ DB Query  │ │    │ │ CSV Parse  │ │
│ └─────┬─────┘ │    │ └─────┬──────┘ │
│       ▼       │    │       ▼        │
│ ┌───────────┐ │    │ ┌────────────┐ │
│ │ Transform │ │    │ │ Validate   │ │
│ └─────┬─────┘ │    │ └─────┬──────┘ │
│       ▼       │    │       ▼        │
│ ┌───────────┐ │    │ ┌────────────┐ │
│ │ CSV Write │ │    │ │ DB Insert  │ │
│ └───────────┘ │    │ └────────────┘ │
└───────────────┘    └────────────────┘
        │                     │
        └──────────┬──────────┘
                   ▼
┌─────────────────────────────────────────────────────┐
│              Job Result Logger                      │
│  - 実行結果記録                                        │
│  - エラーハンドリング                                   │
│  - メトリクス収集                                      │
└─────────────────────────────────────────────────────┘
```

### 2.2 共通設計方針

#### 2.2.1 チャンク処理設計

Next.jsではSpring Batchのようなネイティブチャンク処理がないため、独自実装:

```typescript
// lib/batch/chunk-processor.ts
export async function processInChunks<T, R>(
  items: T[],
  processor: (item: T) => Promise<R>,
  writer: (chunk: R[]) => Promise<void>,
  options: {
    chunkSize?: number;
    skipOnError?: boolean;
    skipLimit?: number;
  } = {}
): Promise<ChunkResult> {
  const {
    chunkSize = 1000,
    skipOnError = true,
    skipLimit = 100
  } = options;

  const results: R[] = [];
  const errors: ProcessError[] = [];
  let skipCount = 0;

  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);
    const processedChunk: R[] = [];

    for (const item of chunk) {
      try {
        const result = await processor(item);
        processedChunk.push(result);
      } catch (error) {
        if (!skipOnError) throw error;

        skipCount++;
        errors.push({
          item,
          error: error instanceof Error ? error.message : String(error),
          index: i + chunk.indexOf(item)
        });

        if (skipCount > skipLimit) {
          throw new Error(`スキップ上限(${skipLimit}件)を超過しました`);
        }
      }
    }

    // チャンク単位でWriter実行
    if (processedChunk.length > 0) {
      await writer(processedChunk);
    }

    results.push(...processedChunk);
  }

  return {
    totalCount: items.length,
    successCount: results.length,
    errorCount: errors.length,
    errors
  };
}

interface ChunkResult {
  totalCount: number;
  successCount: number;
  errorCount: number;
  errors: ProcessError[];
}

interface ProcessError {
  item: any;
  error: string;
  index: number;
}
```

**チャンクサイズ設定基準:**
- 小規模データ(〜10万件): 1000件
- 中規模データ(10万〜100万件): 5000件
- 大規模データ(100万件〜): 10000件

#### 2.2.2 エラーハンドリング方針

```typescript
// lib/batch/error-handler.ts
export class BatchError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly severity: 'SKIP' | 'FATAL',
    public readonly details?: Record<string, any>
  ) {
    super(message);
    this.name = 'BatchError';
  }
}

export const ErrorSeverity = {
  // スキップ可能エラー
  VALIDATION_ERROR: { code: 'VALIDATION_ERROR', severity: 'SKIP' as const },
  BUSINESS_ERROR: { code: 'BUSINESS_ERROR', severity: 'SKIP' as const },

  // 致命的エラー(即時停止)
  DB_CONNECTION_ERROR: { code: 'DB_CONNECTION_ERROR', severity: 'FATAL' as const },
  FILE_IO_ERROR: { code: 'FILE_IO_ERROR', severity: 'FATAL' as const },
  MEMORY_ERROR: { code: 'MEMORY_ERROR', severity: 'FATAL' as const },
  SYSTEM_ERROR: { code: 'SYSTEM_ERROR', severity: 'FATAL' as const }
} as const;

export async function withRetry<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries?: number;
    retryDelay?: number;
    retryableErrors?: string[];
  } = {}
): Promise<T> {
  const { maxRetries = 3, retryDelay = 5000, retryableErrors = [] } = options;

  let lastError: Error;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      const isRetryable = retryableErrors.length === 0 ||
        retryableErrors.some(code => lastError.message.includes(code));

      if (!isRetryable || attempt === maxRetries) {
        throw lastError;
      }

      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }

  throw lastError!;
}
```

**エラー処理設定:**
```yaml
スキップ可能エラー:
  - データ形式不正 (VALIDATION_ERROR)
  - 業務エラー (BUSINESS_ERROR)
  - スキップ上限: 100件

致命的エラー(即時停止):
  - DB接続エラー (DB_CONNECTION_ERROR)
  - ファイルI/Oエラー (FILE_IO_ERROR)
  - メモリ不足 (MEMORY_ERROR)
  - システムエラー (SYSTEM_ERROR)

リトライ対象:
  - 一時的なDB接続エラー
  - ロックタイムアウト
  - リトライ回数: 3回
  - リトライ間隔: 5秒
```

#### 2.2.3 トランザクション設計

```typescript
// lib/db/transaction.ts
import { prisma } from '@/lib/prisma';

export async function executeInTransaction<T>(
  fn: () => Promise<T>,
  options?: {
    timeout?: number;
    isolationLevel?: 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Serializable';
  }
): Promise<T> {
  const { timeout = 300000, isolationLevel = 'ReadCommitted' } = options || {};

  return await prisma.$transaction(
    async (tx) => {
      return await fn();
    },
    {
      maxWait: 5000,
      timeout,
      isolationLevel
    }
  );
}
```

**トランザクション設定:**
```yaml
分離レベル: ReadCommitted
タイムアウト: 300秒 (5分)
最大待機時間: 5秒
ロールバック条件:
  - Error発生時
  - チャンク内エラー件数が上限超過時

コミット単位:
  Chunk処理: チャンクサイズ単位(1000件ごと)
  単一処理: 処理完了時に1回
```

### 2.3 ジョブパラメータ共通仕様

#### 2.3.1 リクエストボディ共通項目

```typescript
// types/batch.ts
export interface BatchJobRequest {
  // 必須パラメータ
  executionDate: string;      // 実行日付(業務日付) ISO8601形式
  executionUser: string;      // 実行ユーザID

  // 共通オプションパラメータ
  dryRun?: boolean;          // ドライラン実行フラグ (default: false)
  logLevel?: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';  // ログレベル (default: INFO)
  chunkSize?: number;        // チャンクサイズ (default: 1000)
  skipLimit?: number;        // スキップ上限件数 (default: 100)
}

export interface BatchJobResponse {
  success: boolean;
  jobId: string;
  executionTime: number;      // 実行時間(ミリ秒)
  statistics: {
    totalCount: number;
    successCount: number;
    errorCount: number;
    skipCount: number;
  };
  errors?: Array<{
    line?: number;
    message: string;
    details?: Record<string, any>;
  }>;
  outputFile?: string;        // 出力ファイルパス(該当する場合)
}
```

---

## 3. BA1060101 プロジェクト一括出力

### 3.1 仕様概要

#### 3.1.1 バッチ概要

| 項目 | 内容 |
|-----|------|
| バッチID | BA1060101 |
| バッチ名 | プロジェクト一括出力 |
| 処理方式 | API Route (Chunk処理) |
| 実行タイミング | オンデマンド(画面からの手動実行) / 日次(深夜2時) |
| 処理概要 | 指定された期間内のプロジェクト情報をCSVファイルに一括出力する |
| 想定処理件数 | 10,000件/実行 |
| 想定処理時間 | 3分 |

#### 3.1.2 業務要件

```yaml
出力対象:
  条件: プロジェクト開始日 <= 終了日 AND プロジェクト終了日 >= 開始日
  ソート順: プロジェクトID昇順

除外条件:
  - 削除フラグが true のプロジェクト
  - ステータスが "99"(論理削除)のプロジェクト

出力形式:
  ファイル形式: CSV (UTF-8 BOM付き)
  ヘッダー: あり
  区切り文字: カンマ
  囲み文字: ダブルクォート
  改行コード: CRLF (Windows)

格納先:
  - 開発環境: /tmp/exports/
  - 本番環境: /var/data/exports/ または S3バケット
```

### 3.2 エンドポイント仕様

#### 3.2.1 API Route

**パス:** `POST /api/jobs/export-projects`

**リクエストボディ:**

```typescript
interface ExportProjectsRequest extends BatchJobRequest {
  startDate: string;          // 抽出開始日 (ISO8601: YYYY-MM-DD)
  endDate: string;            // 抽出終了日 (ISO8601: YYYY-MM-DD)
  includeMembers?: boolean;   // メンバー情報含む (default: false)
  outputPath?: string;        // 出力ファイルパス (default: 自動生成)
}
```

**レスポンス:**

```typescript
interface ExportProjectsResponse extends BatchJobResponse {
  outputFile: string;         // 生成されたCSVファイルパス
  downloadUrl?: string;       // ダウンロードURL(該当する場合)
  fileSize: number;          // ファイルサイズ(バイト)
  recordCount: number;       // 出力レコード数
}
```

**リクエスト例:**

```json
{
  "startDate": "2024-01-01",
  "endDate": "2024-03-31",
  "includeMembers": true,
  "executionDate": "2024-03-15T00:00:00Z",
  "executionUser": "USR001",
  "logLevel": "INFO"
}
```

**レスポンス例:**

```json
{
  "success": true,
  "jobId": "export-20240315-001",
  "executionTime": 180000,
  "statistics": {
    "totalCount": 10000,
    "successCount": 10000,
    "errorCount": 0,
    "skipCount": 0
  },
  "outputFile": "/exports/projects_20240315_140530.csv",
  "downloadUrl": "/api/downloads/projects_20240315_140530.csv",
  "fileSize": 2048576,
  "recordCount": 10000
}
```

#### 3.2.2 パラメータ検証ルール

```typescript
// lib/batch/validators/export-projects.ts
import { z } from 'zod';

export const exportProjectsSchema = z.object({
  startDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, '日付はYYYY-MM-DD形式で指定してください')
    .refine(
      (date) => {
        const d = new Date(date);
        const threeYearsAgo = new Date();
        threeYearsAgo.setFullYear(threeYearsAgo.getFullYear() - 3);
        return d >= threeYearsAgo;
      },
      '開始日はシステム日付の3年前以降を指定してください'
    ),

  endDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, '日付はYYYY-MM-DD形式で指定してください')
    .refine(
      (date) => {
        const d = new Date(date);
        const oneYearLater = new Date();
        oneYearLater.setFullYear(oneYearLater.getFullYear() + 1);
        return d <= oneYearLater;
      },
      '終了日はシステム日付の1年後以内を指定してください'
    ),

  includeMembers: z.boolean().optional().default(false),
  outputPath: z.string()
    .regex(/^\/exports\/.*\.csv$/, '出力パスは/exports/で始まり.csvで終わる必要があります')
    .optional(),

  executionDate: z.string(),
  executionUser: z.string().min(1, '実行ユーザIDは必須です'),

  dryRun: z.boolean().optional().default(false),
  logLevel: z.enum(['DEBUG', 'INFO', 'WARN', 'ERROR']).optional().default('INFO'),
  chunkSize: z.number().int().positive().optional().default(1000),
  skipLimit: z.number().int().positive().optional().default(100)
}).refine(
  (data) => new Date(data.startDate) <= new Date(data.endDate),
  {
    message: '終了日は開始日以降の日付を指定してください',
    path: ['endDate']
  }
);
```

### 3.3 処理フロー

```
開始
  │
  ├─ [Step1: パラメータ検証]
  │   ├─ リクエストボディ検証 (Zod Schema)
  │   ├─ 日付範囲妥当性チェック
  │   ├─ 出力パス検証
  │   └─ 権限チェック
  │
  ├─ [Step2: 出力ディレクトリ準備]
  │   ├─ ディレクトリ存在確認
  │   ├─ 既存ファイル確認
  │   └─ バックアップ作成(既存時)
  │
  ├─ [Step3: プロジェクト情報抽出・出力] (Chunk: 1000件)
  │   │
  │   ├─ [データ読込]
  │   │   ├─ Prisma Query実行(プロジェクト抽出)
  │   │   ├─ ページネーション読込(1000件単位)
  │   │   └─ Entity変換
  │   │
  │   ├─ [データ変換]
  │   │   ├─ 日付フォーマット変換 (ISO8601 → YYYY-MM-DD)
  │   │   ├─ コード名称変換 (JOIN済みデータ使用)
  │   │   ├─ メンバー情報結合(オプション)
  │   │   └─ CSV行データ生成
  │   │
  │   └─ [CSV書込]
  │       ├─ CSVヘッダー出力(初回のみ)
  │       ├─ データ行出力
  │       └─ バッファフラッシュ
  │
  ├─ [Step4: 出力結果検証]
  │   ├─ ファイル存在確認
  │   ├─ 行数確認
  │   ├─ ファイルサイズ確認
  │   └─ チェックサム生成
  │
  └─ [完了処理]
      ├─ 処理サマリログ出力
      ├─ 実行履歴登録 (job_execution_history)
      └─ レスポンス返却
```

### 3.4 実装設計

#### 3.4.1 API Route実装

```typescript
// app/api/jobs/export-projects/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { exportProjectsSchema } from '@/lib/batch/validators/export-projects';
import { ExportProjectsJob } from '@/lib/batch/jobs/export-projects';
import { createBatchLogger } from '@/lib/batch/logger';
import { saveJobExecutionHistory } from '@/lib/batch/history';

export const maxDuration = 300; // 5分 (Vercel Pro以上で必要)
export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  const jobId = `export-${new Date().toISOString().replace(/[:.]/g, '-')}`;
  const logger = createBatchLogger('BA1060101', jobId);

  try {
    // リクエストボディ取得
    const body = await request.json();

    logger.info('バッチ開始', { params: body });

    // パラメータ検証
    const params = exportProjectsSchema.parse(body);

    // ジョブ実行
    const job = new ExportProjectsJob(params, logger);
    const result = await job.execute();

    const executionTime = Date.now() - startTime;

    // 実行履歴保存
    await saveJobExecutionHistory({
      jobId,
      batchId: 'BA1060101',
      batchName: 'プロジェクト一括出力',
      status: 'SUCCESS',
      executionTime,
      parameters: params,
      statistics: result.statistics,
      executedBy: params.executionUser,
      executedAt: new Date(params.executionDate)
    });

    logger.info('バッチ正常終了', {
      executionTime,
      statistics: result.statistics
    });

    return NextResponse.json({
      success: true,
      jobId,
      executionTime,
      ...result
    });

  } catch (error) {
    const executionTime = Date.now() - startTime;

    logger.error('バッチ異常終了', { error });

    // エラー履歴保存
    await saveJobExecutionHistory({
      jobId,
      batchId: 'BA1060101',
      batchName: 'プロジェクト一括出力',
      status: 'FAILED',
      executionTime,
      errorMessage: error instanceof Error ? error.message : String(error),
      executedBy: 'SYSTEM',
      executedAt: new Date()
    });

    return NextResponse.json(
      {
        success: false,
        jobId,
        executionTime,
        error: error instanceof Error ? error.message : '予期しないエラーが発生しました'
      },
      { status: 500 }
    );
  }
}
```

#### 3.4.2 ジョブハンドラ実装

```typescript
// lib/batch/jobs/export-projects.ts
import { prisma } from '@/lib/prisma';
import { createObjectCsvWriter } from 'csv-writer';
import { promises as fs } from 'fs';
import path from 'path';
import { processInChunks } from '@/lib/batch/chunk-processor';
import type { BatchLogger } from '@/lib/batch/logger';

interface ExportParams {
  startDate: string;
  endDate: string;
  includeMembers: boolean;
  outputPath?: string;
  chunkSize: number;
}

export class ExportProjectsJob {
  private outputFilePath: string;

  constructor(
    private params: ExportParams,
    private logger: BatchLogger
  ) {
    this.outputFilePath = params.outputPath ||
      path.join(
        process.env.EXPORT_DIR || '/tmp/exports',
        `projects_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}_${Date.now()}.csv`
      );
  }

  async execute() {
    // 出力ディレクトリ準備
    await this.prepareOutputDirectory();

    // プロジェクトデータ取得
    const projects = await this.fetchProjects();

    this.logger.info('データ取得完了', { count: projects.length });

    // CSV Writer作成
    const csvWriter = await this.createCsvWriter();

    // チャンク処理で変換・書込
    const result = await processInChunks(
      projects,
      async (project) => await this.transformProject(project),
      async (chunk) => await csvWriter.writeRecords(chunk),
      {
        chunkSize: this.params.chunkSize,
        skipOnError: true,
        skipLimit: 100
      }
    );

    // ファイル情報取得
    const stats = await fs.stat(this.outputFilePath);

    return {
      statistics: {
        totalCount: result.totalCount,
        successCount: result.successCount,
        errorCount: result.errorCount,
        skipCount: result.errorCount
      },
      outputFile: this.outputFilePath,
      fileSize: stats.size,
      recordCount: result.successCount,
      errors: result.errors
    };
  }

  private async prepareOutputDirectory() {
    const dir = path.dirname(this.outputFilePath);
    await fs.mkdir(dir, { recursive: true });

    // 既存ファイルのバックアップ
    try {
      await fs.access(this.outputFilePath);
      const backupPath = `${this.outputFilePath}.bak`;
      await fs.rename(this.outputFilePath, backupPath);
      this.logger.info('既存ファイルをバックアップ', { backupPath });
    } catch {
      // ファイルが存在しない場合は何もしない
    }
  }

  private async fetchProjects() {
    const { startDate, endDate, includeMembers } = this.params;

    return await prisma.project.findMany({
      where: {
        deleteFlag: false,
        status: {
          not: '99'
        },
        OR: [
          {
            startDate: {
              lte: new Date(endDate)
            },
            endDate: {
              gte: new Date(startDate)
            }
          }
        ]
      },
      include: {
        projectClass: {
          select: {
            codeName: true
          }
        },
        projectStatus: {
          select: {
            codeName: true
          }
        },
        projectManager: {
          select: {
            userName: true
          }
        },
        client: {
          select: {
            clientName: true
          }
        },
        ...(includeMembers && {
          members: {
            include: {
              user: {
                select: {
                  userId: true,
                  userName: true
                }
              }
            },
            where: {
              deleteFlag: false
            }
          }
        })
      },
      orderBy: {
        projectId: 'asc'
      }
    });
  }

  private async createCsvWriter() {
    const headers = [
      { id: 'projectId', title: 'project_id' },
      { id: 'projectName', title: 'project_name' },
      { id: 'projectNameAbbr', title: 'project_name_abbr' },
      { id: 'projectClass', title: 'project_class' },
      { id: 'projectClassName', title: 'project_class_name' },
      { id: 'startDate', title: 'start_date' },
      { id: 'endDate', title: 'end_date' },
      { id: 'status', title: 'status' },
      { id: 'statusName', title: 'status_name' },
      { id: 'pmUserId', title: 'pm_user_id' },
      { id: 'pmUserName', title: 'pm_user_name' },
      { id: 'clientId', title: 'client_id' },
      { id: 'clientName', title: 'client_name' },
      { id: 'budgetAmount', title: 'budget_amount' },
      { id: 'note', title: 'note' },
      { id: 'createdAt', title: 'created_at' },
      { id: 'updatedAt', title: 'updated_at' }
    ];

    if (this.params.includeMembers) {
      headers.push(
        { id: 'memberCount', title: 'member_count' },
        { id: 'memberIds', title: 'member_ids' },
        { id: 'memberNames', title: 'member_names' }
      );
    }

    const writer = createObjectCsvWriter({
      path: this.outputFilePath,
      header: headers,
      encoding: 'utf8',
      alwaysQuote: true
    });

    // UTF-8 BOM追加
    await fs.writeFile(this.outputFilePath, '\uFEFF', 'utf8');

    return writer;
  }

  private async transformProject(project: any) {
    const record: any = {
      projectId: project.projectId,
      projectName: project.projectName,
      projectNameAbbr: project.projectNameAbbr || '',
      projectClass: project.projectClass,
      projectClassName: project.projectClass?.codeName || '',
      startDate: this.formatDate(project.startDate),
      endDate: this.formatDate(project.endDate),
      status: project.status,
      statusName: project.projectStatus?.codeName || '',
      pmUserId: project.pmUserId || '',
      pmUserName: project.projectManager?.userName || '',
      clientId: project.clientId || '',
      clientName: project.client?.clientName || '',
      budgetAmount: project.budgetAmount?.toString() || '',
      note: this.sanitizeNote(project.note),
      createdAt: this.formatDateTime(project.createdAt),
      updatedAt: this.formatDateTime(project.updatedAt)
    };

    if (this.params.includeMembers && project.members) {
      record.memberCount = project.members.length;
      record.memberIds = project.members.map((m: any) => m.user.userId).join(',');
      record.memberNames = project.members.map((m: any) => m.user.userName).join(',');
    }

    return record;
  }

  private formatDate(date: Date | null): string {
    if (!date) return '';
    return date.toISOString().slice(0, 10);
  }

  private formatDateTime(date: Date | null): string {
    if (!date) return '';
    return date.toISOString().replace('T', ' ').slice(0, 19);
  }

  private sanitizeNote(note: string | null): string {
    if (!note) return '';
    return note.replace(/[\r\n]+/g, ' ').trim();
  }
}
```

### 3.5 Cron設定

#### 3.5.1 Vercel Cron (vercel.json)

```json
{
  "crons": [
    {
      "path": "/api/jobs/export-projects/cron",
      "schedule": "0 2 * * *"
    }
  ]
}
```

#### 3.5.2 Cron専用エンドポイント

```typescript
// app/api/jobs/export-projects/cron/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { headers } from 'next/headers';

export async function GET(request: NextRequest) {
  // Vercel Cronからの呼び出しを検証
  const headersList = headers();
  const cronSecret = headersList.get('authorization');

  if (cronSecret !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // 前日分のプロジェクトを出力
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const dateStr = yesterday.toISOString().slice(0, 10);

  // ジョブ実行
  const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/jobs/export-projects`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      startDate: dateStr,
      endDate: dateStr,
      includeMembers: false,
      executionDate: new Date().toISOString(),
      executionUser: 'CRON_SYSTEM'
    })
  });

  const result = await response.json();

  return NextResponse.json(result);
}
```

#### 3.5.3 node-cron設定 (セルフホスト環境)

```typescript
// lib/cron/jobs.ts
import cron from 'node-cron';
import { createBatchLogger } from '@/lib/batch/logger';

export function registerCronJobs() {
  const logger = createBatchLogger('CRON', 'system');

  // プロジェクト一括出力: 毎日深夜2時
  cron.schedule('0 2 * * *', async () => {
    logger.info('Cronジョブ開始: プロジェクト一括出力');

    try {
      const response = await fetch(`${process.env.INTERNAL_API_URL}/api/jobs/export-projects`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          startDate: new Date().toISOString().slice(0, 10),
          endDate: new Date().toISOString().slice(0, 10),
          includeMembers: false,
          executionDate: new Date().toISOString(),
          executionUser: 'CRON_SYSTEM'
        })
      });

      const result = await response.json();
      logger.info('Cronジョブ完了', { result });
    } catch (error) {
      logger.error('Cronジョブエラー', { error });
    }
  }, {
    timezone: 'Asia/Tokyo'
  });

  logger.info('Cronジョブ登録完了');
}
```

---

## 4. BA1070101 プロジェクト一括登録

### 4.1 仕様概要

#### 4.1.1 バッチ概要

| 項目 | 内容 |
|-----|------|
| バッチID | BA1070101 |
| バッチ名 | プロジェクト一括登録 |
| 処理方式 | API Route (Chunk処理) |
| 実行タイミング | オンデマンド(画面からのファイルアップロード後) |
| 処理概要 | アップロードされたCSVファイルを読み込み、検証後にプロジェクトを一括登録する |
| 想定処理件数 | 5,000件/実行 |
| 想定処理時間 | 2分 |

#### 4.1.2 業務要件

```yaml
処理対象:
  入力ファイル: CSV形式(UTF-8 BOM付き)
  必須ヘッダー: あり(項目名検証)
  最大ファイルサイズ: 100MB
  最大行数: 100,000行

入力チェック:
  形式チェック:
    - 項目数一致
    - データ型妥当性
    - 必須項目存在
    - 文字数上限
  業務チェック:
    - プロジェクトID重複
    - コード値存在チェック
    - ユーザID存在チェック
    - 顧客ID存在チェック
    - 日付論理チェック(開始日≦終了日)

エラー処理:
  エラー行: スキップして次行処理継続
  エラー上限: 100行まで許容
  エラー内容: レスポンスにエラーリスト含める
  エラーCSV: エラー行のみのCSVファイル生成
```

### 4.2 エンドポイント仕様

#### 4.2.1 API Route

**パス:** `POST /api/jobs/import-projects`

**リクエスト形式:** `multipart/form-data`

**フォームフィールド:**

```typescript
interface ImportProjectsFormData {
  file: File;                 // CSVファイル (必須)
  executionDate: string;      // 実行日付 (必須)
  executionUser: string;      // 実行ユーザID (必須)
  dryRun?: string;           // ドライラン ("true" | "false")
  validateOnly?: string;     // 検証のみ ("true" | "false")
}
```

**レスポンス:**

```typescript
interface ImportProjectsResponse extends BatchJobResponse {
  validationErrors?: Array<{
    line: number;
    projectId?: string;
    errors: string[];
  }>;
  errorCsvPath?: string;      // エラー行CSVファイルパス
}
```

**リクエスト例 (cURL):**

```bash
curl -X POST http://localhost:3000/api/jobs/import-projects \
  -F "file=@projects.csv" \
  -F "executionDate=2024-03-15T00:00:00Z" \
  -F "executionUser=USR001" \
  -F "dryRun=false"
```

**レスポンス例:**

```json
{
  "success": true,
  "jobId": "import-20240315-002",
  "executionTime": 120000,
  "statistics": {
    "totalCount": 5000,
    "successCount": 4950,
    "errorCount": 50,
    "skipCount": 50
  },
  "validationErrors": [
    {
      "line": 15,
      "projectId": "PJ999",
      "errors": [
        "プロジェクトID「PJ999」は既に登録されています"
      ]
    },
    {
      "line": 42,
      "projectId": "PJ1042",
      "errors": [
        "終了日は開始日以降の日付を設定してください"
      ]
    }
  ],
  "errorCsvPath": "/tmp/errors/import_errors_20240315_140530.csv"
}
```

### 4.3 処理フロー

```
開始
  │
  ├─ [Step1: ファイル検証]
  │   ├─ ファイル存在確認
  │   ├─ ファイルサイズチェック(上限100MB)
  │   ├─ MIMEタイプ検証 (text/csv)
  │   ├─ 文字コード検証(UTF-8)
  │   └─ ヘッダー行検証
  │
  ├─ [Step2: CSV解析]
  │   ├─ CSV行読込
  │   ├─ 行数カウント(上限10万行)
  │   └─ データ配列変換
  │
  ├─ [Step3: データ検証・登録] (Chunk: 1000件)
  │   │
  │   ├─ [各行の検証]
  │   │   ├─ 形式チェック
  │   │   │   ├─ データ型検証
  │   │   │   ├─ 必須項目検証
  │   │   │   ├─ 文字数検証
  │   │   │   └─ 日付形式検証
  │   │   │
  │   │   ├─ 業務チェック
  │   │   │   ├─ プロジェクトID重複チェック
  │   │   │   ├─ マスタ存在チェック
  │   │   │   │   ├─ コード値(分類・ステータス)
  │   │   │   │   ├─ ユーザID(PM)
  │   │   │   │   └─ 顧客ID
  │   │   │   └─ 日付論理チェック
  │   │   │
  │   │   └─ エラー集約
  │   │
  │   └─ [DB登録]
  │       ├─ トランザクション開始
  │       ├─ バルクINSERT(1000件単位)
  │       ├─ コミット
  │       └─ エラー時ロールバック
  │
  ├─ [Step4: エラーCSV生成] (エラーあり時)
  │   ├─ エラー行抽出
  │   ├─ エラーメッセージ追加
  │   └─ CSV出力
  │
  └─ [完了処理]
      ├─ 処理サマリログ出力
      ├─ 実行履歴登録
      └─ レスポンス返却
```

### 4.4 実装設計

#### 4.4.1 API Route実装

```typescript
// app/api/jobs/import-projects/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { ImportProjectsJob } from '@/lib/batch/jobs/import-projects';
import { createBatchLogger } from '@/lib/batch/logger';
import { saveJobExecutionHistory } from '@/lib/batch/history';

export const maxDuration = 300; // 5分
export const dynamic = 'force-dynamic';

// ファイルサイズ上限設定 (100MB)
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '100mb'
    }
  }
};

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  const jobId = `import-${new Date().toISOString().replace(/[:.]/g, '-')}`;
  const logger = createBatchLogger('BA1070101', jobId);

  try {
    // FormData取得
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const executionDate = formData.get('executionDate') as string;
    const executionUser = formData.get('executionUser') as string;
    const dryRun = formData.get('dryRun') === 'true';
    const validateOnly = formData.get('validateOnly') === 'true';

    // ファイル検証
    if (!file) {
      return NextResponse.json(
        { success: false, error: 'ファイルが指定されていません' },
        { status: 400 }
      );
    }

    if (file.size > 100 * 1024 * 1024) {
      return NextResponse.json(
        { success: false, error: 'ファイルサイズが上限(100MB)を超えています' },
        { status: 400 }
      );
    }

    if (!file.name.endsWith('.csv')) {
      return NextResponse.json(
        { success: false, error: 'CSVファイルを指定してください' },
        { status: 400 }
      );
    }

    logger.info('バッチ開始', {
      fileName: file.name,
      fileSize: file.size,
      dryRun,
      validateOnly
    });

    // ファイル内容読込
    const fileContent = await file.text();

    // ジョブ実行
    const job = new ImportProjectsJob({
      fileContent,
      fileName: file.name,
      executionDate,
      executionUser,
      dryRun,
      validateOnly,
      chunkSize: 1000,
      skipLimit: 100
    }, logger);

    const result = await job.execute();

    const executionTime = Date.now() - startTime;

    // 実行履歴保存
    await saveJobExecutionHistory({
      jobId,
      batchId: 'BA1070101',
      batchName: 'プロジェクト一括登録',
      status: result.statistics.errorCount > 0 ? 'WARNING' : 'SUCCESS',
      executionTime,
      parameters: {
        fileName: file.name,
        fileSize: file.size,
        dryRun,
        validateOnly
      },
      statistics: result.statistics,
      executedBy: executionUser,
      executedAt: new Date(executionDate)
    });

    logger.info('バッチ完了', {
      executionTime,
      statistics: result.statistics
    });

    return NextResponse.json({
      success: true,
      jobId,
      executionTime,
      ...result
    });

  } catch (error) {
    const executionTime = Date.now() - startTime;

    logger.error('バッチ異常終了', { error });

    await saveJobExecutionHistory({
      jobId,
      batchId: 'BA1070101',
      batchName: 'プロジェクト一括登録',
      status: 'FAILED',
      executionTime,
      errorMessage: error instanceof Error ? error.message : String(error),
      executedBy: 'SYSTEM',
      executedAt: new Date()
    });

    return NextResponse.json(
      {
        success: false,
        jobId,
        executionTime,
        error: error instanceof Error ? error.message : '予期しないエラーが発生しました'
      },
      { status: 500 }
    );
  }
}
```

#### 4.4.2 ジョブハンドラ実装

```typescript
// lib/batch/jobs/import-projects.ts
import { prisma } from '@/lib/prisma';
import { parse } from 'csv-parse/sync';
import { stringify } from 'csv-stringify/sync';
import { promises as fs } from 'fs';
import path from 'path';
import { processInChunks } from '@/lib/batch/chunk-processor';
import type { BatchLogger } from '@/lib/batch/logger';
import { z } from 'zod';

interface ImportParams {
  fileContent: string;
  fileName: string;
  executionDate: string;
  executionUser: string;
  dryRun: boolean;
  validateOnly: boolean;
  chunkSize: number;
  skipLimit: number;
}

interface ProjectRecord {
  line: number;
  projectId: string;
  projectName: string;
  projectNameAbbr?: string;
  projectClass: string;
  startDate: string;
  endDate: string;
  status: string;
  pmUserId?: string;
  clientId?: string;
  budgetAmount?: string;
  note?: string;
}

interface ValidationError {
  line: number;
  projectId?: string;
  errors: string[];
}

export class ImportProjectsJob {
  private errorCsvPath?: string;

  constructor(
    private params: ImportParams,
    private logger: BatchLogger
  ) {}

  async execute() {
    // CSV解析
    const records = await this.parseCSV();

    this.logger.info('CSV解析完了', { count: records.length });

    // 検証エラー配列
    const validationErrors: ValidationError[] = [];

    // チャンク処理で検証・登録
    const result = await processInChunks(
      records,
      async (record) => await this.validateAndTransform(record, validationErrors),
      async (chunk) => {
        if (!this.params.validateOnly && !this.params.dryRun) {
          await this.insertProjects(chunk);
        }
      },
      {
        chunkSize: this.params.chunkSize,
        skipOnError: true,
        skipLimit: this.params.skipLimit
      }
    );

    // エラーCSV生成
    if (validationErrors.length > 0) {
      this.errorCsvPath = await this.generateErrorCsv(records, validationErrors);
    }

    return {
      statistics: {
        totalCount: result.totalCount,
        successCount: result.successCount,
        errorCount: validationErrors.length,
        skipCount: validationErrors.length
      },
      validationErrors: validationErrors.slice(0, 100), // 最大100件返却
      errorCsvPath: this.errorCsvPath
    };
  }

  private async parseCSV(): Promise<ProjectRecord[]> {
    try {
      // BOM削除
      const content = this.params.fileContent.replace(/^\uFEFF/, '');

      // CSV解析
      const rawRecords = parse(content, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
        relaxColumnCount: false
      });

      // 行数チェック
      if (rawRecords.length > 100000) {
        throw new Error('CSVファイルの行数が上限(100,000行)を超えています');
      }

      // レコード変換
      return rawRecords.map((record: any, index: number) => ({
        line: index + 2, // ヘッダー行を除く
        projectId: record.project_id,
        projectName: record.project_name,
        projectNameAbbr: record.project_name_abbr,
        projectClass: record.project_class,
        startDate: record.start_date,
        endDate: record.end_date,
        status: record.status,
        pmUserId: record.pm_user_id,
        clientId: record.client_id,
        budgetAmount: record.budget_amount,
        note: record.note
      }));

    } catch (error) {
      throw new Error(`CSV解析エラー: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async validateAndTransform(
    record: ProjectRecord,
    validationErrors: ValidationError[]
  ) {
    const errors: string[] = [];

    // 形式チェック
    errors.push(...this.validateFormat(record));

    // 業務チェック
    if (errors.length === 0) {
      errors.push(...await this.validateBusiness(record));
    }

    // エラーがあればスキップ
    if (errors.length > 0) {
      validationErrors.push({
        line: record.line,
        projectId: record.projectId,
        errors
      });
      throw new Error(`行${record.line}: ${errors.join(', ')}`);
    }

    // Prismaモデル形式に変換
    return {
      projectId: record.projectId,
      projectName: record.projectName,
      projectNameAbbr: record.projectNameAbbr || null,
      projectClass: record.projectClass,
      startDate: new Date(record.startDate),
      endDate: new Date(record.endDate),
      status: record.status,
      pmUserId: record.pmUserId || null,
      clientId: record.clientId || null,
      budgetAmount: record.budgetAmount ? BigInt(record.budgetAmount) : null,
      note: record.note || null,
      deleteFlag: false,
      createdBy: this.params.executionUser,
      updatedBy: this.params.executionUser
    };
  }

  private validateFormat(record: ProjectRecord): string[] {
    const errors: string[] = [];

    // プロジェクトID
    if (!record.projectId) {
      errors.push('プロジェクトIDは必須です');
    } else if (!/^[A-Za-z0-9]{1,10}$/.test(record.projectId)) {
      errors.push('プロジェクトIDは半角英数字10文字以内で入力してください');
    }

    // プロジェクト名
    if (!record.projectName) {
      errors.push('プロジェクト名は必須です');
    } else if (record.projectName.length > 100) {
      errors.push('プロジェクト名は100文字以内で入力してください');
    }

    // プロジェクト分類
    if (!record.projectClass) {
      errors.push('プロジェクト分類は必須です');
    } else if (record.projectClass.length !== 2) {
      errors.push('プロジェクト分類は2桁で入力してください');
    }

    // 開始日
    if (!record.startDate) {
      errors.push('開始日は必須です');
    } else if (!/^\d{4}-\d{2}-\d{2}$/.test(record.startDate)) {
      errors.push('開始日はYYYY-MM-DD形式で入力してください');
    } else if (isNaN(new Date(record.startDate).getTime())) {
      errors.push('開始日に無効な日付が指定されています');
    }

    // 終了日
    if (!record.endDate) {
      errors.push('終了日は必須です');
    } else if (!/^\d{4}-\d{2}-\d{2}$/.test(record.endDate)) {
      errors.push('終了日はYYYY-MM-DD形式で入力してください');
    } else if (isNaN(new Date(record.endDate).getTime())) {
      errors.push('終了日に無効な日付が指定されています');
    }

    // 日付論理チェック
    if (record.startDate && record.endDate &&
        new Date(record.startDate) > new Date(record.endDate)) {
      errors.push('終了日は開始日以降の日付を設定してください');
    }

    // ステータス
    if (!record.status) {
      errors.push('ステータスは必須です');
    } else if (record.status.length !== 2) {
      errors.push('ステータスは2桁で入力してください');
    }

    // 予算金額
    if (record.budgetAmount) {
      if (!/^\d+$/.test(record.budgetAmount)) {
        errors.push('予算金額は数値で入力してください');
      } else if (record.budgetAmount.length > 15) {
        errors.push('予算金額は15桁以内で入力してください');
      }
    }

    // 備考
    if (record.note && record.note.length > 500) {
      errors.push('備考は500文字以内で入力してください');
    }

    return errors;
  }

  private async validateBusiness(record: ProjectRecord): Promise<string[]> {
    const errors: string[] = [];

    try {
      // プロジェクトID重複チェック
      const existingProject = await prisma.project.findFirst({
        where: {
          projectId: record.projectId,
          deleteFlag: false
        }
      });

      if (existingProject) {
        errors.push(`プロジェクトID「${record.projectId}」は既に登録されています`);
      }

      // プロジェクト分類存在チェック
      const projectClassCode = await prisma.code.findFirst({
        where: {
          codeType: 'PROJECT_CLASS',
          codeValue: record.projectClass
        }
      });

      if (!projectClassCode) {
        errors.push(`プロジェクト分類「${record.projectClass}」は存在しません`);
      }

      // ステータス存在チェック
      const statusCode = await prisma.code.findFirst({
        where: {
          codeType: 'PROJECT_STATUS',
          codeValue: record.status
        }
      });

      if (!statusCode) {
        errors.push(`ステータス「${record.status}」は存在しません`);
      }

      // PMユーザID存在チェック
      if (record.pmUserId) {
        const pmUser = await prisma.user.findFirst({
          where: {
            userId: record.pmUserId,
            deleteFlag: false
          }
        });

        if (!pmUser) {
          errors.push(`ユーザID「${record.pmUserId}」は存在しません`);
        }
      }

      // 顧客ID存在チェック
      if (record.clientId) {
        const client = await prisma.client.findFirst({
          where: {
            clientId: record.clientId,
            deleteFlag: false
          }
        });

        if (!client) {
          errors.push(`顧客ID「${record.clientId}」は存在しません`);
        }
      }

    } catch (error) {
      this.logger.error('業務チェックエラー', { error, record });
      errors.push('業務チェック実行中にエラーが発生しました');
    }

    return errors;
  }

  private async insertProjects(projects: any[]) {
    try {
      await prisma.$transaction(async (tx) => {
        await tx.project.createMany({
          data: projects,
          skipDuplicates: true
        });
      });

      this.logger.info('データ登録完了', { count: projects.length });
    } catch (error) {
      this.logger.error('データ登録エラー', { error });
      throw error;
    }
  }

  private async generateErrorCsv(
    records: ProjectRecord[],
    validationErrors: ValidationError[]
  ): Promise<string> {
    const errorLines = new Set(validationErrors.map(e => e.line));
    const errorRecords = records.filter(r => errorLines.has(r.line));

    // エラーメッセージマップ作成
    const errorMap = new Map(
      validationErrors.map(e => [e.line, e.errors.join('; ')])
    );

    // CSVデータ作成
    const csvData = errorRecords.map(record => ({
      line: record.line,
      project_id: record.projectId,
      project_name: record.projectName,
      error_message: errorMap.get(record.line) || ''
    }));

    // CSV文字列生成
    const csvContent = stringify(csvData, {
      header: true,
      columns: ['line', 'project_id', 'project_name', 'error_message']
    });

    // ファイル保存
    const errorDir = process.env.ERROR_CSV_DIR || '/tmp/errors';
    await fs.mkdir(errorDir, { recursive: true });

    const errorFilePath = path.join(
      errorDir,
      `import_errors_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}_${Date.now()}.csv`
    );

    await fs.writeFile(errorFilePath, '\uFEFF' + csvContent, 'utf8');

    this.logger.info('エラーCSV生成完了', { path: errorFilePath });

    return errorFilePath;
  }
}
```

---

## 5. 共通実装パターン

### 5.1 バッチロガー

```typescript
// lib/batch/logger.ts
import winston from 'winston';
import path from 'path';
import { promises as fs } from 'fs';

export interface BatchLogger {
  debug(message: string, meta?: any): void;
  info(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  error(message: string, meta?: any): void;
}

export function createBatchLogger(batchId: string, jobId: string): BatchLogger {
  const logDir = path.join(
    process.env.LOG_DIR || '/tmp/logs',
    'jobs',
    batchId,
    new Date().toISOString().slice(0, 10).replace(/-/g, '')
  );

  // ログディレクトリ作成
  fs.mkdir(logDir, { recursive: true }).catch(console.error);

  const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
      winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
      winston.format.errors({ stack: true }),
      winston.format.json()
    ),
    defaultMeta: { batchId, jobId },
    transports: [
      // コンソール出力
      new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.printf(({ timestamp, level, message, ...meta }) => {
            return `${timestamp} [${level}] [${batchId}/${jobId}] ${message} ${
              Object.keys(meta).length ? JSON.stringify(meta) : ''
            }`;
          })
        )
      }),
      // ファイル出力
      new winston.transports.File({
        filename: path.join(logDir, `${jobId}.log`),
        maxsize: 10485760, // 10MB
        maxFiles: 5
      }),
      // エラーログ
      new winston.transports.File({
        filename: path.join(logDir, `${jobId}_error.log`),
        level: 'error',
        maxsize: 10485760,
        maxFiles: 5
      })
    ]
  });

  return {
    debug: (message, meta) => logger.debug(message, meta),
    info: (message, meta) => logger.info(message, meta),
    warn: (message, meta) => logger.warn(message, meta),
    error: (message, meta) => logger.error(message, meta)
  };
}
```

### 5.2 実行履歴管理

```typescript
// lib/batch/history.ts
import { prisma } from '@/lib/prisma';

export interface JobExecutionHistory {
  jobId: string;
  batchId: string;
  batchName: string;
  status: 'SUCCESS' | 'WARNING' | 'FAILED';
  executionTime: number;
  parameters?: any;
  statistics?: any;
  errorMessage?: string;
  executedBy: string;
  executedAt: Date;
}

export async function saveJobExecutionHistory(history: JobExecutionHistory) {
  try {
    await prisma.jobExecutionHistory.create({
      data: {
        jobId: history.jobId,
        batchId: history.batchId,
        batchName: history.batchName,
        status: history.status,
        executionTime: history.executionTime,
        parameters: history.parameters ? JSON.stringify(history.parameters) : null,
        statistics: history.statistics ? JSON.stringify(history.statistics) : null,
        errorMessage: history.errorMessage || null,
        executedBy: history.executedBy,
        executedAt: history.executedAt
      }
    });
  } catch (error) {
    console.error('実行履歴保存エラー:', error);
  }
}

export async function getJobExecutionHistory(jobId: string) {
  return await prisma.jobExecutionHistory.findUnique({
    where: { jobId }
  });
}

export async function getRecentJobExecutions(batchId: string, limit: number = 10) {
  return await prisma.jobExecutionHistory.findMany({
    where: { batchId },
    orderBy: { executedAt: 'desc' },
    take: limit
  });
}
```

### 5.3 Prismaスキーマ (ジョブ履歴テーブル)

```prisma
// prisma/schema.prisma
model JobExecutionHistory {
  id            String   @id @default(cuid())
  jobId         String   @unique @db.VarChar(50)
  batchId       String   @db.VarChar(20)
  batchName     String   @db.VarChar(100)
  status        String   @db.VarChar(10) // SUCCESS, WARNING, FAILED
  executionTime Int      // ミリ秒
  parameters    String?  @db.Text
  statistics    String?  @db.Text
  errorMessage  String?  @db.Text
  executedBy    String   @db.VarChar(8)
  executedAt    DateTime @db.Timestamp(0)
  createdAt     DateTime @default(now()) @db.Timestamp(0)

  @@index([batchId, executedAt])
  @@index([status])
  @@map("job_execution_history")
}
```

---

## 6. テーブル移送表

### 6.1 BA1060101 プロジェクト一括出力

#### 6.1.1 入力テーブル

| テーブル物理名 | テーブル論理名 | 処理種別 | 想定件数 | 備考 |
|-------------|-------------|---------|---------|------|
| project | プロジェクト | 参照 | 10,000 | 期間条件でフィルタ |
| code | コードマスタ | 参照 | 200 | プロジェクト分類・ステータス名称取得 |
| user | ユーザマスタ | 参照 | 500 | PM名称取得 |
| client | 顧客マスタ | 参照 | 1,000 | 顧客名称取得 |
| project_member | プロジェクトメンバー | 参照 | 50,000 | includeMembers=true時のみ |

#### 6.1.2 出力ファイル

| ファイル名 | 形式 | 想定件数 | 備考 |
|----------|------|---------|------|
| projects_{yyyyMMdd}_{HHmmss}.csv | CSV | 10,000 | UTF-8 BOM付き |

### 6.2 BA1070101 プロジェクト一括登録

#### 6.2.1 入力ファイル

| ファイル名 | 形式 | 最大件数 | 備考 |
|----------|------|---------|------|
| *.csv | CSV | 100,000 | UTF-8 BOM付き、ヘッダー必須 |

#### 6.2.2 出力テーブル

| テーブル物理名 | テーブル論理名 | 処理種別 | 想定件数 | 備考 |
|-------------|-------------|---------|---------|------|
| project | プロジェクト | INSERT | 5,000 | チャンク単位でバルクINSERT |
| job_execution_history | ジョブ実行履歴 | INSERT | 1 | ジョブ実行結果記録 |

#### 6.2.3 参照テーブル (検証用)

| テーブル物理名 | テーブル論理名 | 処理種別 | 備考 |
|-------------|-------------|---------|------|
| project | プロジェクト | 参照 | ID重複チェック |
| code | コードマスタ | 参照 | コード値存在チェック |
| user | ユーザマスタ | 参照 | ユーザID存在チェック |
| client | 顧客マスタ | 参照 | 顧客ID存在チェック |

#### 6.2.4 出力ファイル (エラー時)

| ファイル名 | 形式 | 備考 |
|----------|------|------|
| import_errors_{yyyyMMdd}_{timestamp}.csv | CSV | 検証エラー行のみ出力 |

---

## 補足資料

### A. 依存パッケージ

```json
{
  "dependencies": {
    "csv-parse": "^5.5.0",
    "csv-stringify": "^6.4.0",
    "csv-writer": "^1.6.0",
    "node-cron": "^3.0.3",
    "winston": "^3.11.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node-cron": "^3.0.11"
  }
}
```

### B. 環境変数設定

```bash
# .env
# ログ出力先
LOG_DIR=/var/log/batch
LOG_LEVEL=info

# CSV出力先
EXPORT_DIR=/var/data/exports
ERROR_CSV_DIR=/var/data/errors

# Cron認証
CRON_SECRET=your-secret-token

# アプリケーションURL
NEXT_PUBLIC_APP_URL=https://your-app.com
INTERNAL_API_URL=http://localhost:3000

# データベース
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
```

### C. デプロイ設定

#### Vercel環境

1. **vercel.json** にCron設定追加
2. 環境変数設定 (`CRON_SECRET`, `EXPORT_DIR` 等)
3. Function実行時間制限確認 (Pro: 300秒, Enterprise: 900秒)

#### セルフホスト環境

1. **server.ts** でnode-cron初期化
2. PM2等でプロセス管理
3. ファイルシステム権限設定

```typescript
// server.ts (セルフホスト)
import { createServer } from 'http';
import { parse } from 'url';
import next from 'next';
import { registerCronJobs } from './lib/cron/jobs';

const dev = process.env.NODE_ENV !== 'production';
const app = next({ dev });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  // Cronジョブ登録
  registerCronJobs();

  createServer((req, res) => {
    const parsedUrl = parse(req.url!, true);
    handle(req, res, parsedUrl);
  }).listen(3000, () => {
    console.log('> Ready on http://localhost:3000');
  });
});
```

---

**文書バージョン:** 1.0
**最終更新日:** 2024-03-15
**作成者:** 技術部
**承認者:** プロジェクトマネージャー
