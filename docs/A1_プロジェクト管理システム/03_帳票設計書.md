# 帳票設計書 (Next.js版)

## ドキュメント情報

| 項目 | 内容 |
|------|------|
| システム名 | A1 プロジェクト管理システム |
| ドキュメント名 | 帳票設計書 (Next.js実装) |
| バージョン | 2.0 |
| 最終更新日 | 2025-11-27 |
| 実装技術 | Next.js 14+ App Router, TypeScript |

---

## 目次

1. [仕様概要](#仕様概要)
2. [技術スタック](#技術スタック)
3. [帳票一覧](#帳票一覧)
4. [CSV出力設計](#csv出力設計)
5. [PDF出力設計](#pdf出力設計)
6. [帳票詳細仕様](#帳票詳細仕様)
   - [N21AA001 期間内プロジェクト一覧CSV](#n21aa001-期間内プロジェクト一覧csv)
   - [N21AA003 ユーザ別従事プロジェクト一覧CSV](#n21aa003-ユーザ別従事プロジェクト一覧csv)
   - [N21AA002 プロジェクト詳細PDF](#n21aa002-プロジェクト詳細pdf)
7. [実装ガイド](#実装ガイド)
8. [エラーハンドリング](#エラーハンドリング)
9. [パフォーマンス最適化](#パフォーマンス最適化)
10. [セキュリティ考慮事項](#セキュリティ考慮事項)

---

## 仕様概要

### 目的
本ドキュメントは、Next.js App Routerを使用したA1プロジェクト管理システムの帳票生成機能の仕様を定義する。Spring/Jasper Reportsからの移行に際し、モダンなWeb技術スタックを採用する。

### 対象範囲
- CSV形式で出力される帳票（ストリーミング対応）
- PDF形式で出力される帳票（サーバーサイド生成）
- API Routeによる帳票生成エンドポイント
- クライアントサイドダウンロード機能

### アーキテクチャ概要

```
┌─────────────────┐
│  Client Side    │
│  (React)        │
│  - 検索条件入力  │
│  - ダウンロード   │
└────────┬────────┘
         │ HTTP Request
         ↓
┌─────────────────┐
│  API Routes     │
│  /api/reports/  │
│  - CSV生成      │
│  - PDF生成      │
└────────┬────────┘
         │ Data Query
         ↓
┌─────────────────┐
│  Database       │
│  (PostgreSQL)   │
│  - Prisma ORM   │
└─────────────────┘
```

---

## 技術スタック

### 必須ライブラリ

#### CSV生成
```json
{
  "dependencies": {
    "csv-stringify": "^6.4.5",
    "papaparse": "^5.4.1"
  },
  "devDependencies": {
    "@types/papaparse": "^5.3.14"
  }
}
```

#### PDF生成
```json
{
  "dependencies": {
    "@react-pdf/renderer": "^3.1.14",
    "jspdf": "^2.5.1",
    "jspdf-autotable": "^3.8.0"
  },
  "devDependencies": {
    "@types/jspdf": "^2.0.0"
  }
}
```

### インストールコマンド
```bash
npm install csv-stringify papaparse @react-pdf/renderer jspdf jspdf-autotable
npm install -D @types/papaparse @types/jspdf
```

---

## 帳票一覧

| 帳票ID | 帳票名 | 出力元画面 | 形式 | API Route | 備考 |
|--------|--------|-----------|------|-----------|------|
| N21AA001 | 期間内プロジェクト一覧 | BA1060101 | CSV | `/api/reports/projects/csv` | プロジェクト一覧検索結果 |
| N21AA003 | ユーザ別従事プロジェクト一覧 | BA1060301 | CSV | `/api/reports/users/projects/csv` | ユーザ別プロジェクト従事履歴 |
| N21AA002 | プロジェクト詳細 | BA1060102 | PDF | `/api/reports/projects/[id]/pdf` | 個別プロジェクト詳細 |

---

## CSV出力設計

### 共通仕様

#### ファイル形式
| 項目 | 仕様 |
|------|------|
| 形式 | CSV (Comma-Separated Values) |
| 文字コード | UTF-8 (BOM付き) |
| 改行コード | CRLF (Windows形式) |
| 区切り文字 | カンマ (,) |
| 囲み文字 | ダブルクォーテーション (") |
| エスケープ | ダブルクォーテーションの2重化 |

#### ファイル命名規則
```typescript
// 形式: {帳票ID}_{YYYYMMDD}_{HHmmss}.csv
const generateFileName = (reportId: string): string => {
  const now = new Date();
  const dateStr = format(now, 'yyyyMMdd_HHmmss');
  return `${reportId}_${dateStr}.csv`;
};

// 例: N21AA001_20241201_143022.csv
```

### CSV生成アーキテクチャ

#### 1. ストリーミング方式（推奨）

**利点**:
- メモリ効率的（大量データ対応）
- 即座にダウンロード開始
- サーバー負荷軽減

**実装パターン**:
```typescript
// app/api/reports/projects/csv/route.ts
import { stringify } from 'csv-stringify';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;

  // UTF-8 BOM
  const BOM = '\uFEFF';

  // ReadableStreamを作成
  const stream = new ReadableStream({
    async start(controller) {
      // BOMを先頭に追加
      controller.enqueue(new TextEncoder().encode(BOM));

      const stringifier = stringify({
        header: true,
        columns: [
          { key: 'project_id', header: 'プロジェクトID' },
          { key: 'project_name', header: 'プロジェクト名' },
          { key: 'start_date', header: '開始日' },
          { key: 'end_date', header: '終了日' },
          { key: 'status', header: 'ステータス' },
          { key: 'project_manager', header: 'プロジェクトマネージャー' },
          { key: 'department_name', header: '部署名' },
          { key: 'budget', header: '予算' },
          { key: 'actual_cost', header: '実績コスト' },
          { key: 'progress_rate', header: '進捗率' },
          { key: 'member_count', header: 'メンバー数' },
          { key: 'created_at', header: '登録日時' },
          { key: 'updated_at', header: '更新日時' }
        ],
        cast: {
          date: (value) => value ? format(value, 'yyyy-MM-dd') : '',
          number: (value) => value !== null ? String(value) : '',
          boolean: (value) => value ? '1' : '0'
        }
      });

      // データをストリーミングで処理
      stringifier.on('readable', () => {
        let chunk;
        while ((chunk = stringifier.read()) !== null) {
          controller.enqueue(new TextEncoder().encode(chunk));
        }
      });

      stringifier.on('end', () => {
        controller.close();
      });

      stringifier.on('error', (error) => {
        controller.error(error);
      });

      // データベースからデータを取得してストリーミング
      const data = await fetchProjectsStream(searchParams);

      for await (const row of data) {
        stringifier.write(row);
      }

      stringifier.end();
    }
  });

  return new NextResponse(stream, {
    headers: {
      'Content-Type': 'text/csv; charset=utf-8',
      'Content-Disposition': `attachment; filename="${generateFileName('N21AA001')}"`,
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    }
  });
}
```

#### 2. バッファ方式（小規模データ向け）

**用途**:
- データ件数が少ない場合（<1,000件）
- データの事前検証が必要な場合

**実装パターン**:
```typescript
// app/api/reports/projects/csv/route.ts
import { stringify } from 'csv-stringify/sync';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;

  // データ取得
  const projects = await fetchProjects(searchParams);

  // 件数チェック
  if (projects.length > 10000) {
    return NextResponse.json(
      { error: '出力件数が上限（10,000件）を超えています。検索条件を絞り込んでください。' },
      { status: 400 }
    );
  }

  // CSV生成
  const csv = stringify(projects, {
    header: true,
    columns: [
      { key: 'project_id', header: 'プロジェクトID' },
      { key: 'project_name', header: 'プロジェクト名' },
      // ... 他の列
    ],
    cast: {
      date: (value) => value ? format(value, 'yyyy-MM-dd') : '',
      number: (value) => value !== null ? String(value) : ''
    }
  });

  // UTF-8 BOM + CSV
  const content = '\uFEFF' + csv;

  return new NextResponse(content, {
    headers: {
      'Content-Type': 'text/csv; charset=utf-8',
      'Content-Disposition': `attachment; filename="${generateFileName('N21AA001')}"`,
      'Content-Length': String(Buffer.byteLength(content, 'utf-8'))
    }
  });
}
```

### クライアント側実装

```typescript
// components/reports/DownloadCSVButton.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';

interface DownloadCSVButtonProps {
  searchParams: Record<string, string>;
  reportId: string;
  label: string;
}

export function DownloadCSVButton({
  searchParams,
  reportId,
  label
}: DownloadCSVButtonProps) {
  const [isDownloading, setIsDownloading] = useState(false);

  const handleDownload = async () => {
    setIsDownloading(true);

    try {
      // URLパラメータ構築
      const params = new URLSearchParams(searchParams);
      const url = `/api/reports/projects/csv?${params.toString()}`;

      // ダウンロード実行
      const response = await fetch(url);

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'ダウンロードに失敗しました');
      }

      // Blobとして取得
      const blob = await response.blob();

      // ダウンロード実行
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = response.headers.get('Content-Disposition')
        ?.split('filename=')[1]
        ?.replace(/"/g, '') || `${reportId}.csv`;

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(downloadUrl);

    } catch (error) {
      console.error('CSV download error:', error);
      alert(error instanceof Error ? error.message : 'ダウンロードに失敗しました');
    } finally {
      setIsDownloading(false);
    }
  };

  return (
    <Button
      onClick={handleDownload}
      disabled={isDownloading}
      variant="outline"
    >
      {isDownloading ? 'ダウンロード中...' : label}
    </Button>
  );
}
```

---

## PDF出力設計

### 技術選定

#### Option 1: @react-pdf/renderer（推奨）

**利点**:
- Reactコンポーネントとして記述可能
- 保守性が高い
- TypeScript完全対応
- 日本語フォント対応

**実装例**:
```typescript
// app/api/reports/projects/[id]/pdf/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { renderToBuffer } from '@react-pdf/renderer';
import { ProjectDetailPDF } from '@/components/reports/ProjectDetailPDF';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // データ取得
    const project = await fetchProjectDetail(params.id);

    if (!project) {
      return NextResponse.json(
        { error: 'プロジェクトが見つかりません' },
        { status: 404 }
      );
    }

    // PDF生成
    const pdfBuffer = await renderToBuffer(
      <ProjectDetailPDF project={project} />
    );

    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="project_${params.id}_${format(new Date(), 'yyyyMMdd')}.pdf"`,
        'Content-Length': String(pdfBuffer.length)
      }
    });
  } catch (error) {
    console.error('PDF generation error:', error);
    return NextResponse.json(
      { error: 'PDF生成に失敗しました' },
      { status: 500 }
    );
  }
}
```

```typescript
// components/reports/ProjectDetailPDF.tsx
import React from 'react';
import { Document, Page, Text, View, StyleSheet, Font } from '@react-pdf/renderer';

// 日本語フォント登録
Font.register({
  family: 'NotoSansJP',
  fonts: [
    {
      src: '/fonts/NotoSansJP-Regular.ttf',
      fontWeight: 'normal'
    },
    {
      src: '/fonts/NotoSansJP-Bold.ttf',
      fontWeight: 'bold'
    }
  ]
});

const styles = StyleSheet.create({
  page: {
    flexDirection: 'column',
    backgroundColor: '#FFFFFF',
    padding: 30,
    fontFamily: 'NotoSansJP',
    fontSize: 10
  },
  header: {
    marginBottom: 20,
    borderBottom: 2,
    borderBottomColor: '#2563eb',
    paddingBottom: 10
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#1e40af',
    marginBottom: 5
  },
  subtitle: {
    fontSize: 10,
    color: '#64748b'
  },
  section: {
    marginBottom: 15
  },
  sectionTitle: {
    fontSize: 12,
    fontWeight: 'bold',
    backgroundColor: '#f1f5f9',
    padding: 5,
    marginBottom: 8
  },
  table: {
    display: 'flex',
    width: 'auto',
    borderStyle: 'solid',
    borderWidth: 1,
    borderColor: '#cbd5e1'
  },
  tableRow: {
    flexDirection: 'row',
    borderBottomWidth: 1,
    borderBottomColor: '#cbd5e1'
  },
  tableColHeader: {
    width: '30%',
    backgroundColor: '#f8fafc',
    padding: 8,
    fontWeight: 'bold'
  },
  tableCol: {
    width: '70%',
    padding: 8
  },
  footer: {
    position: 'absolute',
    bottom: 30,
    left: 30,
    right: 30,
    textAlign: 'center',
    color: '#94a3b8',
    fontSize: 8,
    borderTop: 1,
    borderTopColor: '#e2e8f0',
    paddingTop: 10
  }
});

interface ProjectDetailPDFProps {
  project: {
    project_id: string;
    project_name: string;
    start_date: Date;
    end_date: Date;
    status: string;
    project_manager: string;
    department_name: string;
    budget: number | null;
    actual_cost: number | null;
    progress_rate: number | null;
    member_count: number;
    description?: string;
    created_at: Date;
    updated_at: Date;
  };
}

export function ProjectDetailPDF({ project }: ProjectDetailPDFProps) {
  return (
    <Document>
      <Page size="A4" style={styles.page}>
        {/* ヘッダー */}
        <View style={styles.header}>
          <Text style={styles.title}>プロジェクト詳細レポート</Text>
          <Text style={styles.subtitle}>
            出力日時: {format(new Date(), 'yyyy年MM月dd日 HH:mm')}
          </Text>
        </View>

        {/* 基本情報 */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>基本情報</Text>
          <View style={styles.table}>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>プロジェクトID</Text>
              <Text style={styles.tableCol}>{project.project_id}</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>プロジェクト名</Text>
              <Text style={styles.tableCol}>{project.project_name}</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>ステータス</Text>
              <Text style={styles.tableCol}>{project.status}</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>期間</Text>
              <Text style={styles.tableCol}>
                {format(project.start_date, 'yyyy/MM/dd')} ～ {format(project.end_date, 'yyyy/MM/dd')}
              </Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>プロジェクトマネージャー</Text>
              <Text style={styles.tableCol}>{project.project_manager}</Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>部署</Text>
              <Text style={styles.tableCol}>{project.department_name}</Text>
            </View>
          </View>
        </View>

        {/* コスト情報 */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>コスト情報</Text>
          <View style={styles.table}>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>予算</Text>
              <Text style={styles.tableCol}>
                {project.budget ? `¥${project.budget.toLocaleString()}` : '-'}
              </Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>実績コスト</Text>
              <Text style={styles.tableCol}>
                {project.actual_cost ? `¥${project.actual_cost.toLocaleString()}` : '-'}
              </Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>進捗率</Text>
              <Text style={styles.tableCol}>
                {project.progress_rate !== null ? `${project.progress_rate}%` : '-'}
              </Text>
            </View>
            <View style={styles.tableRow}>
              <Text style={styles.tableColHeader}>メンバー数</Text>
              <Text style={styles.tableCol}>{project.member_count}名</Text>
            </View>
          </View>
        </View>

        {/* フッター */}
        <Text style={styles.footer}>
          A1 プロジェクト管理システム - 機密区分: 社外秘
        </Text>
      </Page>
    </Document>
  );
}
```

#### Option 2: jsPDF（テーブル中心の場合）

**利点**:
- シンプルな表形式に最適
- jspdf-autotableで表が簡単
- ファイルサイズが小さい

**実装例**:
```typescript
// lib/reports/pdf-generator.ts
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export function generateProjectListPDF(projects: Project[]): Buffer {
  const doc = new jsPDF({
    orientation: 'landscape',
    unit: 'mm',
    format: 'a4'
  });

  // 日本語フォント読み込み（事前に追加が必要）
  // doc.addFont('/fonts/NotoSansJP-Regular.ttf', 'NotoSansJP', 'normal');
  // doc.setFont('NotoSansJP');

  // タイトル
  doc.setFontSize(16);
  doc.text('プロジェクト一覧', 14, 15);

  doc.setFontSize(10);
  doc.text(`出力日時: ${format(new Date(), 'yyyy年MM月dd日 HH:mm')}`, 14, 22);

  // テーブル生成
  autoTable(doc, {
    startY: 30,
    head: [[
      'プロジェクトID',
      'プロジェクト名',
      '開始日',
      '終了日',
      'ステータス',
      'PM',
      '予算',
      '進捗率'
    ]],
    body: projects.map(p => [
      p.project_id,
      p.project_name,
      format(p.start_date, 'yyyy/MM/dd'),
      format(p.end_date, 'yyyy/MM/dd'),
      p.status,
      p.project_manager,
      p.budget ? `¥${p.budget.toLocaleString()}` : '-',
      p.progress_rate !== null ? `${p.progress_rate}%` : '-'
    ]),
    styles: {
      font: 'NotoSansJP',
      fontSize: 9,
      cellPadding: 2
    },
    headStyles: {
      fillColor: [37, 99, 235],
      textColor: [255, 255, 255],
      fontStyle: 'bold'
    },
    alternateRowStyles: {
      fillColor: [248, 250, 252]
    }
  });

  // フッター
  const pageCount = doc.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.text(
      `${i} / ${pageCount}`,
      doc.internal.pageSize.getWidth() / 2,
      doc.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
  }

  // Bufferとして返す
  return Buffer.from(doc.output('arraybuffer'));
}
```

---

## 帳票詳細仕様

### N21AA001 期間内プロジェクト一覧CSV

#### 仕様概要

| 項目 | 内容 |
|------|------|
| 帳票ID | N21AA001 |
| 帳票名 | 期間内プロジェクト一覧 |
| 出力元画面 | BA1060101 プロジェクト一覧画面 |
| API Route | `/api/reports/projects/csv` |
| HTTPメソッド | GET |
| 出力条件 | 画面で設定した検索条件に合致するプロジェクト |
| ソート順 | プロジェクトID 昇順 |
| 最大出力件数 | 10,000件 |

#### 出力項目仕様

| No | 項目名(日本語) | 項目名(英語) | データ型 | 桁数 | 必須 | 備考 |
|----|--------------|-------------|---------|------|------|------|
| 1 | プロジェクトID | project_id | 文字列 | 10 | ○ | 一意識別子 |
| 2 | プロジェクト名 | project_name | 文字列 | 100 | ○ | |
| 3 | 開始日 | start_date | 日付 | 10 | ○ | YYYY-MM-DD |
| 4 | 終了日 | end_date | 日付 | 10 | ○ | YYYY-MM-DD |
| 5 | ステータス | status | 文字列 | 20 | ○ | 計画中/進行中/完了/中止 |
| 6 | プロジェクトマネージャー | project_manager | 文字列 | 50 | ○ | ユーザ名 |
| 7 | 部署名 | department_name | 文字列 | 50 | ○ | |
| 8 | 予算 | budget | 数値 | 15 | △ | 単位:円 |
| 9 | 実績コスト | actual_cost | 数値 | 15 | △ | 単位:円 |
| 10 | 進捗率 | progress_rate | 数値 | 5 | △ | 単位:% (0-100) |
| 11 | メンバー数 | member_count | 数値 | 5 | ○ | 人数 |
| 12 | 登録日時 | created_at | 日時 | 19 | ○ | YYYY-MM-DD HH:mm:ss |
| 13 | 更新日時 | updated_at | 日時 | 19 | ○ | YYYY-MM-DD HH:mm:ss |

#### API実装例

```typescript
// app/api/reports/projects/csv/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { stringify } from 'csv-stringify';
import { prisma } from '@/lib/prisma';
import { format } from 'date-fns';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export const dynamic = 'force-dynamic';
export const maxDuration = 60; // 60秒タイムアウト

interface ProjectCSVRow {
  project_id: string;
  project_name: string;
  start_date: string;
  end_date: string;
  status: string;
  project_manager: string;
  department_name: string;
  budget: string;
  actual_cost: string;
  progress_rate: string;
  member_count: string;
  created_at: string;
  updated_at: string;
}

export async function GET(request: NextRequest) {
  try {
    // 認証チェック
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    // 検索パラメータ取得
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const status = searchParams.get('status');
    const departmentId = searchParams.get('departmentId');

    // クエリ条件構築
    const where: any = {};

    if (startDate) {
      where.start_date = { gte: new Date(startDate) };
    }
    if (endDate) {
      where.end_date = { lte: new Date(endDate) };
    }
    if (status) {
      where.status = status;
    }
    if (departmentId) {
      where.department_id = departmentId;
    }

    // 権限による絞り込み
    if (session.user.role !== 'ADMIN') {
      where.department_id = session.user.departmentId;
    }

    // 件数チェック
    const count = await prisma.project.count({ where });
    if (count > 10000) {
      return NextResponse.json(
        {
          error: '出力件数が上限（10,000件）を超えています。検索条件を絞り込んでください。',
          count
        },
        { status: 400 }
      );
    }

    // ストリーミング生成
    const stream = new ReadableStream({
      async start(controller) {
        const BOM = '\uFEFF';
        controller.enqueue(new TextEncoder().encode(BOM));

        const stringifier = stringify({
          header: true,
          columns: [
            { key: 'project_id', header: 'プロジェクトID' },
            { key: 'project_name', header: 'プロジェクト名' },
            { key: 'start_date', header: '開始日' },
            { key: 'end_date', header: '終了日' },
            { key: 'status', header: 'ステータス' },
            { key: 'project_manager', header: 'プロジェクトマネージャー' },
            { key: 'department_name', header: '部署名' },
            { key: 'budget', header: '予算' },
            { key: 'actual_cost', header: '実績コスト' },
            { key: 'progress_rate', header: '進捗率' },
            { key: 'member_count', header: 'メンバー数' },
            { key: 'created_at', header: '登録日時' },
            { key: 'updated_at', header: '更新日時' }
          ]
        });

        stringifier.on('readable', () => {
          let chunk;
          while ((chunk = stringifier.read()) !== null) {
            controller.enqueue(new TextEncoder().encode(chunk));
          }
        });

        stringifier.on('end', () => {
          controller.close();
        });

        stringifier.on('error', (error) => {
          console.error('CSV stringify error:', error);
          controller.error(error);
        });

        try {
          // データ取得（カーソルベースで大量データ対応）
          const projects = await prisma.project.findMany({
            where,
            orderBy: { project_id: 'asc' },
            include: {
              manager: {
                select: { name: true }
              },
              department: {
                select: { name: true }
              },
              _count: {
                select: { members: true }
              }
            }
          });

          // データ変換して書き込み
          for (const project of projects) {
            const row: ProjectCSVRow = {
              project_id: project.project_id,
              project_name: project.project_name,
              start_date: format(project.start_date, 'yyyy-MM-dd'),
              end_date: format(project.end_date, 'yyyy-MM-dd'),
              status: project.status,
              project_manager: project.manager.name,
              department_name: project.department.name,
              budget: project.budget !== null ? String(project.budget) : '',
              actual_cost: project.actual_cost !== null ? String(project.actual_cost) : '',
              progress_rate: project.progress_rate !== null ? String(project.progress_rate) : '',
              member_count: String(project._count.members),
              created_at: format(project.created_at, 'yyyy-MM-dd HH:mm:ss'),
              updated_at: format(project.updated_at, 'yyyy-MM-dd HH:mm:ss')
            };

            stringifier.write(row);
          }

          stringifier.end();
        } catch (error) {
          console.error('Database query error:', error);
          stringifier.destroy();
          controller.error(error);
        }
      }
    });

    const fileName = `N21AA001_${format(new Date(), 'yyyyMMdd_HHmmss')}.csv`;

    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });

  } catch (error) {
    console.error('CSV generation error:', error);
    return NextResponse.json(
      { error: 'CSV生成に失敗しました' },
      { status: 500 }
    );
  }
}
```

#### ヘッダー行
```csv
プロジェクトID,プロジェクト名,開始日,終了日,ステータス,プロジェクトマネージャー,部署名,予算,実績コスト,進捗率,メンバー数,登録日時,更新日時
```

#### サンプルデータ
```csv
プロジェクトID,プロジェクト名,開始日,終了日,ステータス,プロジェクトマネージャー,部署名,予算,実績コスト,進捗率,メンバー数,登録日時,更新日時
"PRJ0000001","新販売管理システム開発","2024-04-01","2024-09-30","進行中","山田太郎","システム開発部",50000000,25000000,50,15,"2024-03-15 09:00:00","2024-11-20 14:30:00"
"PRJ0000002","業務効率化プロジェクト","2024-05-01","2024-08-31","進行中","佐藤花子","業務改善部",30000000,18000000,60,8,"2024-04-10 10:30:00","2024-11-15 16:45:00"
"PRJ0000003","セキュリティ強化施策","2024-01-15","2024-03-31","完了","鈴木一郎","情報セキュリティ部",20000000,19500000,100,5,"2023-12-01 13:00:00","2024-04-05 17:00:00"
```

---

### N21AA003 ユーザ別従事プロジェクト一覧CSV

#### 仕様概要

| 項目 | 内容 |
|------|------|
| 帳票ID | N21AA003 |
| 帳票名 | ユーザ別従事プロジェクト一覧 |
| 出力元画面 | BA1060301 ユーザ別プロジェクト一覧画面 |
| API Route | `/api/reports/users/projects/csv` |
| HTTPメソッド | GET |
| 出力条件 | 画面で設定した検索条件（ユーザID、期間）に合致するプロジェクト従事情報 |
| ソート順 | ユーザID 昇順、開始日 降順 |
| 最大出力件数 | 10,000件 |

#### 出力項目仕様

| No | 項目名(日本語) | 項目名(英語) | データ型 | 桁数 | 必須 | 備考 |
|----|--------------|-------------|---------|------|------|------|
| 1 | ユーザID | user_id | 文字列 | 10 | ○ | 一意識別子 |
| 2 | ユーザ名 | user_name | 文字列 | 50 | ○ | 姓名 |
| 3 | 部署名 | department_name | 文字列 | 50 | ○ | |
| 4 | プロジェクトID | project_id | 文字列 | 10 | ○ | 一意識別子 |
| 5 | プロジェクト名 | project_name | 文字列 | 100 | ○ | |
| 6 | 役割 | role | 文字列 | 30 | ○ | PM/PL/メンバー/サポート |
| 7 | 開始日 | start_date | 日付 | 10 | ○ | YYYY-MM-DD |
| 8 | 終了日 | end_date | 日付 | 10 | △ | YYYY-MM-DD、進行中の場合は空 |
| 9 | 稼働率 | workload_rate | 数値 | 5 | ○ | 単位:% (0-100) |
| 10 | プロジェクトステータス | project_status | 文字列 | 20 | ○ | 計画中/進行中/完了/中止 |
| 11 | 工数(人日) | work_hours | 数値 | 8,2 | △ | 小数点以下2桁 |
| 12 | 評価 | evaluation | 文字列 | 10 | △ | S/A/B/C/D |
| 13 | 備考 | remarks | 文字列 | 200 | △ | |
| 14 | 登録日時 | created_at | 日時 | 19 | ○ | YYYY-MM-DD HH:mm:ss |
| 15 | 更新日時 | updated_at | 日時 | 19 | ○ | YYYY-MM-DD HH:mm:ss |

#### API実装例

```typescript
// app/api/reports/users/projects/csv/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { stringify } from 'csv-stringify';
import { prisma } from '@/lib/prisma';
import { format } from 'date-fns';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export const dynamic = 'force-dynamic';
export const maxDuration = 60;

interface UserProjectCSVRow {
  user_id: string;
  user_name: string;
  department_name: string;
  project_id: string;
  project_name: string;
  role: string;
  start_date: string;
  end_date: string;
  workload_rate: string;
  project_status: string;
  work_hours: string;
  evaluation: string;
  remarks: string;
  created_at: string;
  updated_at: string;
}

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    const searchParams = request.nextUrl.searchParams;
    const userId = searchParams.get('userId');
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    const where: any = {};

    if (userId) {
      where.user_id = userId;
    }
    if (startDate || endDate) {
      where.AND = [];
      if (startDate) {
        where.AND.push({ start_date: { gte: new Date(startDate) } });
      }
      if (endDate) {
        where.AND.push({
          OR: [
            { end_date: { lte: new Date(endDate) } },
            { end_date: null }
          ]
        });
      }
    }

    // 権限チェック
    if (session.user.role !== 'ADMIN' && !userId) {
      where.user_id = session.user.id;
    }

    const count = await prisma.projectMember.count({ where });
    if (count > 10000) {
      return NextResponse.json(
        {
          error: '出力件数が上限（10,000件）を超えています。検索条件を絞り込んでください。',
          count
        },
        { status: 400 }
      );
    }

    const stream = new ReadableStream({
      async start(controller) {
        const BOM = '\uFEFF';
        controller.enqueue(new TextEncoder().encode(BOM));

        const stringifier = stringify({
          header: true,
          columns: [
            { key: 'user_id', header: 'ユーザID' },
            { key: 'user_name', header: 'ユーザ名' },
            { key: 'department_name', header: '部署名' },
            { key: 'project_id', header: 'プロジェクトID' },
            { key: 'project_name', header: 'プロジェクト名' },
            { key: 'role', header: '役割' },
            { key: 'start_date', header: '開始日' },
            { key: 'end_date', header: '終了日' },
            { key: 'workload_rate', header: '稼働率' },
            { key: 'project_status', header: 'プロジェクトステータス' },
            { key: 'work_hours', header: '工数(人日)' },
            { key: 'evaluation', header: '評価' },
            { key: 'remarks', header: '備考' },
            { key: 'created_at', header: '登録日時' },
            { key: 'updated_at', header: '更新日時' }
          ]
        });

        stringifier.on('readable', () => {
          let chunk;
          while ((chunk = stringifier.read()) !== null) {
            controller.enqueue(new TextEncoder().encode(chunk));
          }
        });

        stringifier.on('end', () => {
          controller.close();
        });

        stringifier.on('error', (error) => {
          console.error('CSV stringify error:', error);
          controller.error(error);
        });

        try {
          const members = await prisma.projectMember.findMany({
            where,
            orderBy: [
              { user_id: 'asc' },
              { start_date: 'desc' }
            ],
            include: {
              user: {
                select: {
                  user_id: true,
                  name: true,
                  department: {
                    select: { name: true }
                  }
                }
              },
              project: {
                select: {
                  project_id: true,
                  project_name: true,
                  status: true
                }
              }
            }
          });

          for (const member of members) {
            const row: UserProjectCSVRow = {
              user_id: member.user.user_id,
              user_name: member.user.name,
              department_name: member.user.department.name,
              project_id: member.project.project_id,
              project_name: member.project.project_name,
              role: member.role,
              start_date: format(member.start_date, 'yyyy-MM-dd'),
              end_date: member.end_date ? format(member.end_date, 'yyyy-MM-dd') : '',
              workload_rate: String(member.workload_rate),
              project_status: member.project.status,
              work_hours: member.work_hours !== null ? member.work_hours.toFixed(2) : '',
              evaluation: member.evaluation || '',
              remarks: member.remarks || '',
              created_at: format(member.created_at, 'yyyy-MM-dd HH:mm:ss'),
              updated_at: format(member.updated_at, 'yyyy-MM-dd HH:mm:ss')
            };

            stringifier.write(row);
          }

          stringifier.end();
        } catch (error) {
          console.error('Database query error:', error);
          stringifier.destroy();
          controller.error(error);
        }
      }
    });

    const fileName = `N21AA003_${format(new Date(), 'yyyyMMdd_HHmmss')}.csv`;

    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/csv; charset=utf-8',
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Cache-Control': 'no-cache, no-store, must-revalidate'
      }
    });

  } catch (error) {
    console.error('CSV generation error:', error);
    return NextResponse.json(
      { error: 'CSV生成に失敗しました' },
      { status: 500 }
    );
  }
}
```

---

### N21AA002 プロジェクト詳細PDF

#### 仕様概要

| 項目 | 内容 |
|------|------|
| 帳票ID | N21AA002 |
| 帳票名 | プロジェクト詳細 |
| 出力元画面 | BA1060102 プロジェクト詳細画面 |
| API Route | `/api/reports/projects/[id]/pdf` |
| HTTPメソッド | GET |
| 出力条件 | 指定されたプロジェクトIDの詳細情報 |
| ページサイズ | A4縦 |
| 日本語フォント | Noto Sans JP |

#### 出力内容

1. **ヘッダー部**
   - タイトル: "プロジェクト詳細レポート"
   - 出力日時: YYYY年MM月DD日 HH:mm

2. **基本情報セクション**
   - プロジェクトID
   - プロジェクト名
   - ステータス
   - 期間（開始日～終了日）
   - プロジェクトマネージャー
   - 部署名
   - プロジェクト概要

3. **コスト情報セクション**
   - 予算
   - 実績コスト
   - 予算消化率
   - 進捗率
   - メンバー数

4. **メンバー一覧セクション**
   - ユーザ名
   - 役割
   - 稼働率
   - 開始日～終了日

5. **フッター部**
   - ページ番号
   - 機密区分
   - システム名

#### 完全実装例

```typescript
// app/api/reports/projects/[id]/pdf/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { renderToBuffer } from '@react-pdf/renderer';
import { ProjectDetailPDF } from '@/components/reports/ProjectDetailPDF';
import { prisma } from '@/lib/prisma';
import { format } from 'date-fns';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: '認証が必要です' }, { status: 401 });
    }

    const project = await prisma.project.findUnique({
      where: { id: params.id },
      include: {
        manager: {
          select: { name: true }
        },
        department: {
          select: { name: true }
        },
        members: {
          include: {
            user: {
              select: { name: true }
            }
          },
          orderBy: { start_date: 'desc' }
        }
      }
    });

    if (!project) {
      return NextResponse.json(
        { error: 'プロジェクトが見つかりません' },
        { status: 404 }
      );
    }

    // 権限チェック
    if (session.user.role !== 'ADMIN' &&
        project.department_id !== session.user.departmentId) {
      return NextResponse.json(
        { error: 'アクセス権限がありません' },
        { status: 403 }
      );
    }

    // PDF生成
    const pdfBuffer = await renderToBuffer(
      <ProjectDetailPDF project={project} />
    );

    const fileName = `project_${project.project_id}_${format(new Date(), 'yyyyMMdd')}.pdf`;

    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${fileName}"`,
        'Content-Length': String(pdfBuffer.length),
        'Cache-Control': 'no-cache'
      }
    });

  } catch (error) {
    console.error('PDF generation error:', error);
    return NextResponse.json(
      { error: 'PDF生成に失敗しました' },
      { status: 500 }
    );
  }
}
```

---

## 実装ガイド

### プロジェクトセットアップ

#### 1. ディレクトリ構成

```
app/
├── api/
│   └── reports/
│       ├── projects/
│       │   ├── csv/
│       │   │   └── route.ts          # N21AA001 CSV
│       │   └── [id]/
│       │       └── pdf/
│       │           └── route.ts      # N21AA002 PDF
│       └── users/
│           └── projects/
│               └── csv/
│                   └── route.ts      # N21AA003 CSV
├── (dashboard)/
│   └── projects/
│       ├── page.tsx                  # プロジェクト一覧画面
│       └── [id]/
│           └── page.tsx              # プロジェクト詳細画面
components/
└── reports/
    ├── DownloadCSVButton.tsx
    ├── DownloadPDFButton.tsx
    └── ProjectDetailPDF.tsx
lib/
├── reports/
│   ├── csv-generator.ts
│   ├── pdf-generator.ts
│   └── types.ts
└── utils/
    └── file-utils.ts
public/
└── fonts/
    ├── NotoSansJP-Regular.ttf
    ├── NotoSansJP-Bold.ttf
    └── NotoSansJP-Medium.ttf
```

#### 2. 日本語フォント準備

```bash
# Noto Sans JPフォントダウンロード
mkdir -p public/fonts
cd public/fonts

# Google Fontsから取得
curl -o NotoSansJP-Regular.ttf "https://github.com/google/fonts/raw/main/ofl/notosansjp/NotoSansJP-Regular.ttf"
curl -o NotoSansJP-Bold.ttf "https://github.com/google/fonts/raw/main/ofl/notosansjp/NotoSansJP-Bold.ttf"
```

#### 3. 型定義

```typescript
// lib/reports/types.ts
export interface ProjectCSVData {
  project_id: string;
  project_name: string;
  start_date: Date;
  end_date: Date;
  status: string;
  project_manager: string;
  department_name: string;
  budget: number | null;
  actual_cost: number | null;
  progress_rate: number | null;
  member_count: number;
  created_at: Date;
  updated_at: Date;
}

export interface UserProjectCSVData {
  user_id: string;
  user_name: string;
  department_name: string;
  project_id: string;
  project_name: string;
  role: string;
  start_date: Date;
  end_date: Date | null;
  workload_rate: number;
  project_status: string;
  work_hours: number | null;
  evaluation: string | null;
  remarks: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface ReportSearchParams {
  startDate?: string;
  endDate?: string;
  status?: string;
  departmentId?: string;
  userId?: string;
}

export const MAX_EXPORT_RECORDS = 10000;
```

#### 4. ユーティリティ関数

```typescript
// lib/utils/file-utils.ts
import { format } from 'date-fns';

export function generateFileName(
  reportId: string,
  extension: 'csv' | 'pdf',
  additionalInfo?: string
): string {
  const timestamp = format(new Date(), 'yyyyMMdd_HHmmss');
  const parts = [reportId];

  if (additionalInfo) {
    parts.push(additionalInfo);
  }

  parts.push(timestamp);

  return `${parts.join('_')}.${extension}`;
}

export function formatDateForCSV(date: Date | null): string {
  return date ? format(date, 'yyyy-MM-dd') : '';
}

export function formatDateTimeForCSV(date: Date): string {
  return format(date, 'yyyy-MM-dd HH:mm:ss');
}

export function formatNumberForCSV(value: number | null): string {
  return value !== null ? String(value) : '';
}

export function formatDecimalForCSV(value: number | null, decimals: number = 2): string {
  return value !== null ? value.toFixed(decimals) : '';
}

export const UTF8_BOM = '\uFEFF';
```

---

## エラーハンドリング

### エラー分類と対応

#### 1. データ量超過エラー

```typescript
// lib/reports/validators.ts
export async function validateRecordCount(
  count: number,
  maxRecords: number = MAX_EXPORT_RECORDS
): Promise<{ valid: boolean; error?: string }> {
  if (count > maxRecords) {
    return {
      valid: false,
      error: `出力件数が上限（${maxRecords.toLocaleString()}件）を超えています。検索条件を絞り込んでください。現在の件数: ${count.toLocaleString()}件`
    };
  }
  return { valid: true };
}
```

#### 2. データ不整合エラー

```typescript
// lib/reports/error-handlers.ts
export class DataIntegrityError extends Error {
  constructor(
    public tableName: string,
    public fieldName: string,
    public recordId: string
  ) {
    super(`データ不整合: ${tableName}.${fieldName} が NULL (ID: ${recordId})`);
    this.name = 'DataIntegrityError';
  }
}

export function validateRequiredFields<T>(
  record: T,
  requiredFields: (keyof T)[]
): { valid: boolean; missingFields: string[] } {
  const missingFields: string[] = [];

  for (const field of requiredFields) {
    if (record[field] === null || record[field] === undefined) {
      missingFields.push(String(field));
    }
  }

  return {
    valid: missingFields.length === 0,
    missingFields
  };
}
```

#### 3. ファイル生成エラー

```typescript
// app/api/reports/projects/csv/route.ts
try {
  // CSV生成処理
} catch (error) {
  console.error('CSV generation error:', {
    error,
    timestamp: new Date().toISOString(),
    params: Object.fromEntries(searchParams)
  });

  if (error instanceof DataIntegrityError) {
    return NextResponse.json(
      {
        error: 'データに不整合があります。システム管理者に連絡してください。',
        details: error.message
      },
      { status: 500 }
    );
  }

  return NextResponse.json(
    { error: 'ファイル出力に失敗しました。システム管理者に連絡してください。' },
    { status: 500 }
  );
}
```

#### 4. 権限エラー

```typescript
export async function checkReportPermission(
  session: Session,
  departmentId?: string
): Promise<{ hasPermission: boolean; error?: string }> {
  if (!session) {
    return {
      hasPermission: false,
      error: '認証が必要です'
    };
  }

  if (session.user.role === 'ADMIN') {
    return { hasPermission: true };
  }

  if (departmentId && departmentId !== session.user.departmentId) {
    return {
      hasPermission: false,
      error: '他部署のデータにはアクセスできません'
    };
  }

  return { hasPermission: true };
}
```

---

## パフォーマンス最適化

### 1. データベースクエリ最適化

```typescript
// lib/reports/db-optimizations.ts
import { Prisma } from '@prisma/client';

export const projectCSVSelect = Prisma.validator<Prisma.ProjectSelect>()({
  project_id: true,
  project_name: true,
  start_date: true,
  end_date: true,
  status: true,
  budget: true,
  actual_cost: true,
  progress_rate: true,
  created_at: true,
  updated_at: true,
  manager: {
    select: { name: true }
  },
  department: {
    select: { name: true }
  },
  _count: {
    select: { members: true }
  }
});

// カーソルベースページネーション（超大量データ向け）
export async function* fetchProjectsWithCursor(
  where: Prisma.ProjectWhereInput,
  batchSize: number = 1000
) {
  let cursor: string | undefined;

  while (true) {
    const projects = await prisma.project.findMany({
      where,
      select: projectCSVSelect,
      orderBy: { project_id: 'asc' },
      take: batchSize,
      ...(cursor && { skip: 1, cursor: { id: cursor } })
    });

    if (projects.length === 0) break;

    yield projects;

    if (projects.length < batchSize) break;

    cursor = projects[projects.length - 1].id;
  }
}
```

### 2. ストリーミング最適化

```typescript
// lib/reports/streaming.ts
export async function createCSVStream<T>(
  dataIterator: AsyncIterableIterator<T[]>,
  columns: Array<{ key: keyof T; header: string }>,
  transformer: (row: T) => Record<string, string>
): Promise<ReadableStream> {
  return new ReadableStream({
    async start(controller) {
      const BOM = '\uFEFF';
      controller.enqueue(new TextEncoder().encode(BOM));

      const stringifier = stringify({
        header: true,
        columns: columns.map(col => ({
          key: String(col.key),
          header: col.header
        }))
      });

      stringifier.on('readable', () => {
        let chunk;
        while ((chunk = stringifier.read()) !== null) {
          controller.enqueue(new TextEncoder().encode(chunk));
        }
      });

      stringifier.on('end', () => controller.close());
      stringifier.on('error', (error) => controller.error(error));

      try {
        for await (const batch of dataIterator) {
          for (const row of batch) {
            stringifier.write(transformer(row));
          }
        }
        stringifier.end();
      } catch (error) {
        stringifier.destroy();
        controller.error(error);
      }
    }
  });
}
```

### 3. メモリ使用量監視

```typescript
// lib/reports/memory-monitor.ts
export function checkMemoryUsage(): {
  used: number;
  total: number;
  percentage: number;
} {
  const used = process.memoryUsage();
  const total = (require('os') as any).totalmem();

  return {
    used: used.heapUsed,
    total,
    percentage: (used.heapUsed / total) * 100
  };
}

export function warnIfHighMemoryUsage(threshold: number = 80): void {
  const { percentage } = checkMemoryUsage();

  if (percentage > threshold) {
    console.warn(`⚠️ High memory usage detected: ${percentage.toFixed(2)}%`);
  }
}
```

---

## セキュリティ考慮事項

### 1. アクセス制御実装

```typescript
// middleware/report-auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function withReportAuth(
  request: NextRequest,
  handler: (session: Session) => Promise<NextResponse>
) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json(
      { error: '認証が必要です' },
      { status: 401 }
    );
  }

  // レート制限チェック
  const rateLimitResult = await checkRateLimit(session.user.id, 'report_download');
  if (!rateLimitResult.allowed) {
    return NextResponse.json(
      {
        error: 'ダウンロード上限に達しました。しばらく待ってから再試行してください。',
        retryAfter: rateLimitResult.retryAfter
      },
      {
        status: 429,
        headers: {
          'Retry-After': String(rateLimitResult.retryAfter)
        }
      }
    );
  }

  return handler(session);
}
```

### 2. SQLインジェクション対策

```typescript
// Prismaを使用することで自動的に対策されるが、追加の検証も実施
export function sanitizeSearchParams(params: URLSearchParams): ReportSearchParams {
  const sanitized: ReportSearchParams = {};

  const startDate = params.get('startDate');
  if (startDate && /^\d{4}-\d{2}-\d{2}$/.test(startDate)) {
    sanitized.startDate = startDate;
  }

  const endDate = params.get('endDate');
  if (endDate && /^\d{4}-\d{2}-\d{2}$/.test(endDate)) {
    sanitized.endDate = endDate;
  }

  const status = params.get('status');
  const validStatuses = ['計画中', '進行中', '完了', '中止'];
  if (status && validStatuses.includes(status)) {
    sanitized.status = status;
  }

  return sanitized;
}
```

### 3. ダウンロード監査ログ

```typescript
// lib/audit/report-audit.ts
export async function logReportDownload(params: {
  userId: string;
  reportId: string;
  recordCount: number;
  searchParams: Record<string, string>;
  ipAddress: string;
  userAgent: string;
}) {
  await prisma.auditLog.create({
    data: {
      user_id: params.userId,
      action: 'REPORT_DOWNLOAD',
      resource_type: 'REPORT',
      resource_id: params.reportId,
      metadata: {
        record_count: params.recordCount,
        search_params: params.searchParams,
        ip_address: params.ipAddress,
        user_agent: params.userAgent
      },
      timestamp: new Date()
    }
  });
}
```

### 4. レート制限

```typescript
// lib/rate-limit/report-limiter.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

export async function checkRateLimit(
  userId: string,
  action: string,
  limit: number = 10,
  window: number = 3600 // 1時間
): Promise<{ allowed: boolean; retryAfter?: number }> {
  const key = `rate_limit:${action}:${userId}`;
  const count = await redis.incr(key);

  if (count === 1) {
    await redis.expire(key, window);
  }

  if (count > limit) {
    const ttl = await redis.ttl(key);
    return {
      allowed: false,
      retryAfter: ttl > 0 ? ttl : window
    };
  }

  return { allowed: true };
}
```

---

## 補足事項

### テスト実装例

```typescript
// __tests__/api/reports/projects/csv.test.ts
import { GET } from '@/app/api/reports/projects/csv/route';
import { NextRequest } from 'next/server';

jest.mock('@/lib/prisma');
jest.mock('next-auth');

describe('GET /api/reports/projects/csv', () => {
  it('認証されていない場合は401を返す', async () => {
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost/api/reports/projects/csv');
    const response = await GET(request);

    expect(response.status).toBe(401);
  });

  it('正常にCSVを生成する', async () => {
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { id: 'user1', role: 'ADMIN' }
    });

    (prisma.project.count as jest.Mock).mockResolvedValue(100);
    (prisma.project.findMany as jest.Mock).mockResolvedValue([
      {
        project_id: 'PRJ001',
        project_name: 'テストプロジェクト',
        // ... 他のフィールド
      }
    ]);

    const request = new NextRequest('http://localhost/api/reports/projects/csv');
    const response = await GET(request);

    expect(response.status).toBe(200);
    expect(response.headers.get('Content-Type')).toBe('text/csv; charset=utf-8');
  });

  it('件数制限を超える場合は400を返す', async () => {
    (getServerSession as jest.Mock).mockResolvedValue({
      user: { id: 'user1', role: 'ADMIN' }
    });

    (prisma.project.count as jest.Mock).mockResolvedValue(15000);

    const request = new NextRequest('http://localhost/api/reports/projects/csv');
    const response = await GET(request);

    expect(response.status).toBe(400);
    const json = await response.json();
    expect(json.error).toContain('10,000件');
  });
});
```

---

## 改版履歴

| バージョン | 日付 | 作成者 | 変更内容 |
|-----------|------|--------|---------|
| 1.0 | 2025-11-27 | - | 初版作成（Spring/Jasper版） |
| 2.0 | 2025-11-27 | - | Next.js実装版に全面改訂 |

---

## 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| 作成者 | | | |
| レビュー担当 | | | |
| 承認者 | | | |

---

**文書管理番号**: A1-DOC-003-NEXTJS
**機密区分**: 社外秘
**技術スタック**: Next.js 14+, TypeScript, Prisma, csv-stringify, @react-pdf/renderer
