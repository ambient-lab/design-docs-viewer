# 開発標準

## 文書情報

| 項目 | 内容 |
|------|------|
| システム名 | サンプルプロジェクト |
| 文書名 | 開発標準 |
| 版数 | 2.0 |
| 作成日 | 2025-11-27 |
| 最終更新日 | 2025-11-27 |

## 目次

1. [UI標準](#ui標準)
   - [画面レイアウト規約](#画面レイアウト規約)
   - [Reactコンポーネント規約](#reactコンポーネント規約)
   - [Tailwind CSSスタイリング規約](#tailwind-cssスタイリング規約)
   - [レスポンシブデザイン規約](#レスポンシブデザイン規約)
   - [shadcn/ui利用規約](#shadcnui利用規約)
   - [メッセージ表示規約](#メッセージ表示規約)
2. [コーディング規約](#コーディング規約)
   - [TypeScript命名規約](#typescript命名規約)
   - [ディレクトリ構成標準](#ディレクトリ構成標準)
   - [コンポーネント設計パターン](#コンポーネント設計パターン)
   - [カスタムフック規約](#カスタムフック規約)
3. [テスト標準](#テスト標準)
   - [Jest + React Testing Library規約](#jest--react-testing-library規約)
   - [Playwright E2Eテスト規約](#playwright-e2eテスト規約)
   - [テストカバレッジ要件](#テストカバレッジ要件)
4. [セキュリティ標準](#セキュリティ標準)
   - [NextAuth.js認証規約](#nextauthjs認証規約)
   - [API Routes セキュリティ](#api-routes-セキュリティ)
   - [入力値検証（Zod）](#入力値検証zod)
   - [XSS対策](#xss対策)

---

## UI標準

### 画面レイアウト規約

#### 基本レイアウト構成

すべての画面は以下の標準構成に従うこと。

```
┌─────────────────────────────────────────────────┐
│ ヘッダー部                                        │
│ - アプリケーション名                               │
│ - ナビゲーションメニュー                           │
│ - ログインユーザー情報                             │
│ - ログアウトボタン                                 │
├─────────────────────────────────────────────────┤
│ パンくずリスト                                    │
│ TOP > プロジェクト管理 > プロジェクト一覧           │
├─────────────────────────────────────────────────┤
│ タイトル部                                        │
│ - 画面タイトル（h1）                              │
│ - 画面説明（オプション）                           │
├─────────────────────────────────────────────────┤
│ メッセージ表示領域                                 │
│ - エラーメッセージ / 警告メッセージ / 情報メッセージ │
├─────────────────────────────────────────────────┤
│ コンテンツ部                                      │
│ - 入力フォーム                                    │
│ - 検索条件エリア                                   │
│ - 検索結果一覧                                    │
│ - 詳細表示エリア                                   │
├─────────────────────────────────────────────────┤
│ ボタンエリア                                      │
│ - アクションボタン（登録、更新、削除等）             │
│ - 戻るボタン                                      │
├─────────────────────────────────────────────────┤
│ フッター部                                        │
│ - コピーライト表示                                 │
│ - バージョン情報                                   │
└─────────────────────────────────────────────────┘
```

#### レイアウト規則

| 項目 | 規則 |
|------|------|
| 画面幅 | 最小768px、最大1920pxで可変対応（Tailwindブレークポイント準拠） |
| コンテンツ領域 | 中央寄せ、最大幅1280px（container mx-auto max-w-7xl） |
| 余白 | Tailwindスペーシングスケール使用（p-4, p-6等） |
| 行間 | leading-relaxed（1.625）を基本とする |
| フォント | システムフォント、text-base（16px）基本 |
| カラー | Tailwind色パレット使用（primary: blue-600、secondary: gray-600） |

#### レイアウトコンポーネント例

```tsx
// app/layout.tsx
import { Header } from '@/components/layout/header'
import { Footer } from '@/components/layout/footer'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body className="min-h-screen flex flex-col">
        <Header />
        <main className="flex-1 container mx-auto max-w-7xl px-4 py-6">
          {children}
        </main>
        <Footer />
      </body>
    </html>
  )
}
```

### Reactコンポーネント規約

#### コンポーネント分類

| 種別 | 説明 | 配置場所 | 例 |
|-----|------|---------|---|
| Server Component | サーバーサイドレンダリング、デフォルト | app/ ディレクトリ | page.tsx, layout.tsx |
| Client Component | クライアントサイド対話処理 | components/ | 'use client'付きコンポーネント |
| Layout Component | 共通レイアウト | components/layout/ | Header, Footer, Sidebar |
| UI Component | 再利用可能UI部品 | components/ui/ | Button, Input, Card |
| Feature Component | 機能固有コンポーネント | components/features/ | ProjectForm, ProjectList |

#### コンポーネント構造

```tsx
// components/features/project-form.tsx
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { projectFormSchema } from '@/lib/validations/project'

interface ProjectFormProps {
  onSubmit: (data: ProjectFormData) => Promise<void>
  defaultValues?: Partial<ProjectFormData>
}

export function ProjectForm({ onSubmit, defaultValues }: ProjectFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(projectFormSchema),
    defaultValues,
  })

  const handleFormSubmit = async (data: ProjectFormData) => {
    setIsSubmitting(true)
    try {
      await onSubmit(data)
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-6">
      <div className="space-y-2">
        <label htmlFor="projectName" className="text-sm font-medium">
          ※プロジェクト名
        </label>
        <Input
          id="projectName"
          {...register('projectName')}
          className={errors.projectName ? 'border-red-500' : ''}
        />
        {errors.projectName && (
          <p className="text-sm text-red-500">{errors.projectName.message}</p>
        )}
      </div>

      <div className="flex justify-end gap-2">
        <Button type="button" variant="outline">
          キャンセル
        </Button>
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? '送信中...' : '登録'}
        </Button>
      </div>
    </form>
  )
}
```

#### コンポーネント設計原則

1. **単一責任の原則**
   - 1つのコンポーネントは1つの責務のみを持つ
   - 複雑なコンポーネントは小さな部品に分割

2. **Props型定義**
   - すべてのPropsにTypeScript型定義を付与
   - interfaceまたはtype aliasを使用
   - オプショナルなPropsには`?`を付与

3. **状態管理**
   - ローカル状態: `useState`, `useReducer`
   - サーバー状態: React Query / SWR
   - グローバル状態: Zustand / Jotai（必要な場合のみ）

4. **イベントハンドラー命名**
   - `handle〜` プレフィックス（例: `handleSubmit`, `handleClick`）
   - Propsとして受け取る場合は `on〜`（例: `onClick`, `onSubmit`）

### Tailwind CSSスタイリング規約

#### クラス名記述順序

以下の順序でクラス名を記述すること（Prettier pluginで自動整形）。

1. レイアウト（display, position）
2. サイズ（width, height）
3. スペーシング（margin, padding）
4. タイポグラフィ
5. 視覚効果（background, border）
6. インタラクション（hover, focus）

```tsx
// 推奨例
<div className="flex items-center justify-between w-full px-4 py-2 text-sm font-medium bg-white border border-gray-200 rounded-lg hover:bg-gray-50">

// 非推奨例（順序不統一）
<div className="bg-white text-sm flex px-4 border w-full hover:bg-gray-50 py-2">
```

#### カスタムスタイルの制限

- 可能な限りTailwindユーティリティクラスを使用
- カスタムCSSは最小限に抑える
- 再利用する場合は`@apply`でコンポーネント化

```css
/* globals.css */
@layer components {
  .btn-primary {
    @apply px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed;
  }
}
```

#### カラーパレット

| 用途 | Tailwindクラス | カラーコード |
|-----|--------------|-------------|
| プライマリ | blue-600 | #2563eb |
| セカンダリ | gray-600 | #4b5563 |
| 成功 | green-600 | #16a34a |
| 警告 | yellow-500 | #eab308 |
| エラー | red-600 | #dc2626 |
| 情報 | blue-500 | #3b82f6 |

#### スペーシングスケール

| サイズ | Tailwind | px値 | 用途 |
|-------|---------|------|------|
| xs | space-2 | 8px | 密接な要素間 |
| sm | space-3 | 12px | 関連要素間 |
| md | space-4 | 16px | セクション内要素間 |
| lg | space-6 | 24px | セクション間 |
| xl | space-8 | 32px | 大きなセクション間 |

### レスポンシブデザイン規約

#### ブレークポイント

Tailwindデフォルトブレークポイントを使用。

| サイズ | min-width | 用途 |
|-------|-----------|------|
| sm | 640px | スマートフォン（横向き） |
| md | 768px | タブレット |
| lg | 1024px | ノートPC |
| xl | 1280px | デスクトップ |
| 2xl | 1536px | 大型ディスプレイ |

#### モバイルファーストアプローチ

```tsx
// モバイル → デスクトップの順で記述
<div className="
  flex flex-col gap-4          /* モバイル: 縦並び */
  md:flex-row md:gap-6         /* タブレット以上: 横並び */
  lg:gap-8                     /* PC: より広い間隔 */
">
```

#### レスポンシブ対応必須項目

1. **ナビゲーション**
   - モバイル: ハンバーガーメニュー
   - デスクトップ: 横並びメニュー

2. **テーブル**
   - モバイル: カード形式または横スクロール
   - デスクトップ: 通常のテーブル表示

3. **フォーム**
   - モバイル: 縦並び、フル幅
   - デスクトップ: グリッドレイアウト

4. **画像**
   - すべてのデバイスで適切なサイズ表示
   - Next.js Imageコンポーネント使用必須

```tsx
import Image from 'next/image'

<Image
  src="/image.jpg"
  alt="説明"
  width={800}
  height={600}
  className="w-full h-auto"
  priority // LCP対象画像の場合
/>
```

### shadcn/ui利用規約

#### コンポーネント導入方法

```bash
# コンポーネント個別インストール（推奨）
npx shadcn-ui@latest add button
npx shadcn-ui@latest add input
npx shadcn-ui@latest add form
```

#### 利用コンポーネント一覧

| コンポーネント | 用途 | カスタマイズ |
|-------------|------|------------|
| Button | アクションボタン | variant, sizeで制御 |
| Input | テキスト入力 | エラー状態の追加可 |
| Form | フォーム管理 | react-hook-form統合 |
| Select | セレクトボックス | 検索機能追加可 |
| Dialog | モーダルダイアログ | 確認ダイアログ等 |
| Alert | メッセージ表示 | variant指定 |
| Table | データテーブル | ソート・ページング追加可 |
| Card | カード表示 | セクション区切り |
| Tabs | タブUI | 画面内切り替え |
| Breadcrumb | パンくずリスト | ナビゲーション |

#### カスタマイズ規則

- shadcn/uiコンポーネントは`components/ui/`に配置される
- プロジェクト固有のカスタマイズは直接編集可
- 共通カスタマイズは`lib/utils.ts`の`cn()`関数を使用

```tsx
import { cn } from '@/lib/utils'
import { Button } from '@/components/ui/button'

<Button className={cn('w-full', isLoading && 'opacity-50')}>
  送信
</Button>
```

#### ボタンバリアント

```tsx
<Button variant="default">デフォルト</Button>      // 青背景
<Button variant="secondary">セカンダリ</Button>    // 灰背景
<Button variant="destructive">削除</Button>        // 赤背景
<Button variant="outline">アウトライン</Button>    // 枠線のみ
<Button variant="ghost">ゴースト</Button>          // 背景なし
```

### メッセージ表示規約

#### メッセージ種別

| 種別 | Alertバリアント | アイコン | 用途 |
|-----|---------------|---------|------|
| エラー | destructive | AlertCircle | 入力エラー、システムエラー |
| 警告 | default（黄色） | AlertTriangle | 注意喚起、確認事項 |
| 情報 | default（青色） | Info | 処理完了、一般情報 |
| 成功 | default（緑色） | CheckCircle | 処理成功 |

#### メッセージコンポーネント実装

```tsx
// components/ui/message.tsx
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert'
import { AlertCircle, CheckCircle, Info, AlertTriangle } from 'lucide-react'

type MessageType = 'error' | 'warning' | 'info' | 'success'

interface MessageProps {
  type: MessageType
  title: string
  message: string | string[]
  code?: string
}

export function Message({ type, title, message, code }: MessageProps) {
  const icons = {
    error: AlertCircle,
    warning: AlertTriangle,
    info: Info,
    success: CheckCircle,
  }

  const variants = {
    error: 'destructive',
    warning: 'default',
    info: 'default',
    success: 'default',
  }

  const Icon = icons[type]

  return (
    <Alert variant={variants[type]} className={getAlertColor(type)}>
      <Icon className="h-4 w-4" />
      <AlertTitle>
        {code && `[${code}] `}
        {title}
      </AlertTitle>
      <AlertDescription>
        {Array.isArray(message) ? (
          <ul className="list-disc list-inside space-y-1">
            {message.map((msg, i) => (
              <li key={i}>{msg}</li>
            ))}
          </ul>
        ) : (
          message
        )}
      </AlertDescription>
    </Alert>
  )
}

function getAlertColor(type: MessageType) {
  const colors = {
    error: 'border-red-500 bg-red-50',
    warning: 'border-yellow-500 bg-yellow-50',
    info: 'border-blue-500 bg-blue-50',
    success: 'border-green-500 bg-green-50',
  }
  return colors[type]
}
```

#### メッセージ表示位置

1. **全体メッセージ**
   - ページ上部（タイトル下）に表示
   - トーストメッセージも併用可（Sonner使用）

2. **項目別エラーメッセージ**
   - 該当入力項目の直下に赤文字で表示
   - react-hook-formのerrorsを使用

3. **確認ダイアログ**
   - shadcn/ui Dialogコンポーネント使用
   - 削除等の重要操作前にモーダル表示

```tsx
// 確認ダイアログ例
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'

<AlertDialog open={isOpen} onOpenChange={setIsOpen}>
  <AlertDialogContent>
    <AlertDialogHeader>
      <AlertDialogTitle>削除確認</AlertDialogTitle>
      <AlertDialogDescription>
        このプロジェクトを削除してもよろしいですか？
        この操作は取り消せません。
      </AlertDialogDescription>
    </AlertDialogHeader>
    <AlertDialogFooter>
      <AlertDialogCancel>キャンセル</AlertDialogCancel>
      <AlertDialogAction onClick={handleDelete}>
        削除
      </AlertDialogAction>
    </AlertDialogFooter>
  </AlertDialogContent>
</AlertDialog>
```

#### トーストメッセージ（Sonner）

```tsx
// app/layout.tsx
import { Toaster } from 'sonner'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Toaster position="top-right" />
      </body>
    </html>
  )
}

// 使用例
import { toast } from 'sonner'

toast.success('プロジェクトを登録しました')
toast.error('エラーが発生しました')
toast.warning('注意: データが古い可能性があります')
toast.info('処理を開始しました')
```

---

## コーディング規約

### TypeScript命名規約

#### ファイル名

| 種別 | 規則 | 例 |
|-----|------|---|
| Reactコンポーネント | kebab-case.tsx | project-form.tsx |
| ページコンポーネント | page.tsx / layout.tsx | app/project/page.tsx |
| API Route | route.ts | app/api/projects/route.ts |
| 型定義ファイル | kebab-case.ts | project-types.ts |
| ユーティリティ | kebab-case.ts | date-utils.ts |
| カスタムフック | use-kebab-case.ts | use-projects.ts |

#### コンポーネント名・クラス名

- PascalCase（先頭大文字）
- 複数単語を連結

```typescript
// コンポーネント
export function ProjectForm() { }
export function UserProfileCard() { }

// クラス
class ProjectService { }
class ValidationError extends Error { }
```

#### 関数名・変数名

- camelCase（先頭小文字）
- 動詞で始まる関数名

```typescript
// 関数
function fetchProjects() { }
function calculateTotalAmount() { }
function validateProjectDate() { }

// 変数
const projectName = 'Sample'
const startDate = new Date()
const isActive = true
const hasError = false
```

#### 型・インターフェース名

| 種別 | 規則 | 例 |
|-----|------|---|
| Interface | PascalCase | ProjectFormData, UserInfo |
| Type Alias | PascalCase | ProjectStatus, ApiResponse |
| Generic型 | 大文字1文字またはPascalCase | T, TData, TResponse |
| Props型 | コンポーネント名 + Props | ProjectFormProps |

```typescript
// Interface
interface Project {
  id: string
  name: string
  startDate: Date
}

// Type Alias
type ProjectStatus = 'active' | 'completed' | 'cancelled'

// Props型
interface ProjectFormProps {
  onSubmit: (data: ProjectFormData) => Promise<void>
  defaultValues?: Partial<ProjectFormData>
}

// Generic型
function fetchData<TData>(url: string): Promise<TData> { }
```

#### 定数名

- SCREAMING_SNAKE_CASE（すべて大文字、アンダースコア区切り）
- constで定義

```typescript
export const DEFAULT_PAGE_SIZE = 20
export const MAX_RETRY_COUNT = 3
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL

// 列挙型定数
export const PROJECT_STATUS = {
  ACTIVE: 'active',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled',
} as const
```

#### 真偽値の命名

- `is`, `has`, `can`, `should` プレフィックスを使用

```typescript
const isLoading = true
const hasError = false
const canEdit = checkPermission()
const shouldShowModal = !isComplete
```

### ディレクトリ構成標準

#### App Routerディレクトリ構造

```
project-root/
├── app/                              # App Router（ルーティング）
│   ├── (auth)/                       # 認証関連ルート（グループ化）
│   │   ├── login/
│   │   │   └── page.tsx
│   │   └── register/
│   │       └── page.tsx
│   ├── (dashboard)/                  # ダッシュボード（認証後）
│   │   ├── layout.tsx                # 共通レイアウト
│   │   ├── page.tsx                  # ダッシュボードトップ
│   │   ├── projects/
│   │   │   ├── page.tsx              # プロジェクト一覧
│   │   │   ├── [id]/
│   │   │   │   ├── page.tsx          # プロジェクト詳細
│   │   │   │   └── edit/
│   │   │   │       └── page.tsx      # プロジェクト編集
│   │   │   └── new/
│   │   │       └── page.tsx          # プロジェクト新規登録
│   │   └── users/
│   │       └── page.tsx
│   ├── api/                          # API Routes
│   │   ├── auth/
│   │   │   └── [...nextauth]/
│   │   │       └── route.ts          # NextAuth設定
│   │   ├── projects/
│   │   │   ├── route.ts              # GET /api/projects
│   │   │   └── [id]/
│   │   │       └── route.ts          # GET/PUT/DELETE /api/projects/:id
│   │   └── users/
│   │       └── route.ts
│   ├── layout.tsx                    # ルートレイアウト
│   └── globals.css                   # グローバルスタイル
│
├── components/                       # Reactコンポーネント
│   ├── ui/                           # shadcn/ui コンポーネント
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── form.tsx
│   │   ├── alert.tsx
│   │   └── ...
│   ├── layout/                       # レイアウトコンポーネント
│   │   ├── header.tsx
│   │   ├── footer.tsx
│   │   ├── sidebar.tsx
│   │   └── breadcrumb.tsx
│   └── features/                     # 機能別コンポーネント
│       ├── projects/
│       │   ├── project-form.tsx
│       │   ├── project-list.tsx
│       │   ├── project-card.tsx
│       │   └── project-detail.tsx
│       └── users/
│           └── user-profile.tsx
│
├── lib/                              # ライブラリ・ユーティリティ
│   ├── auth.ts                       # 認証関連ユーティリティ
│   ├── db.ts                         # データベース接続（Prisma等）
│   ├── utils.ts                      # 汎用ユーティリティ（cn関数等）
│   ├── validations/                  # Zodスキーマ定義
│   │   ├── project.ts
│   │   └── user.ts
│   └── api/                          # APIクライアント
│       ├── client.ts
│       └── endpoints/
│           ├── projects.ts
│           └── users.ts
│
├── hooks/                            # カスタムフック
│   ├── use-projects.ts               # プロジェクト関連フック
│   ├── use-auth.ts                   # 認証フック
│   └── use-toast.ts                  # トーストメッセージフック
│
├── types/                            # TypeScript型定義
│   ├── project.ts
│   ├── user.ts
│   └── api.ts
│
├── constants/                        # 定数定義
│   ├── messages.ts                   # メッセージ定数
│   └── config.ts                     # アプリケーション設定
│
├── prisma/                           # Prisma（ORM）
│   ├── schema.prisma                 # データベーススキーマ
│   └── migrations/                   # マイグレーションファイル
│
├── public/                           # 静的ファイル
│   ├── images/
│   └── fonts/
│
└── tests/                            # テストファイル
    ├── unit/                         # 単体テスト
    ├── integration/                  # 統合テスト
    └── e2e/                          # E2Eテスト（Playwright）
```

### コンポーネント設計パターン

#### Server Components vs Client Components

| 種別 | 用途 | 特徴 | 例 |
|-----|------|------|---|
| Server Component | データ取得、静的コンテンツ | デフォルト、'use client'不要 | ページレイアウト、一覧表示 |
| Client Component | インタラクション、状態管理 | 'use client'必須 | フォーム、モーダル、検索UI |

```tsx
// Server Component（デフォルト）
// app/projects/page.tsx
import { ProjectList } from '@/components/features/projects/project-list'

async function getProjects() {
  const res = await fetch('http://localhost:3000/api/projects', {
    cache: 'no-store', // 常に最新データ取得
  })
  return res.json()
}

export default async function ProjectsPage() {
  const projects = await getProjects()

  return (
    <div>
      <h1>プロジェクト一覧</h1>
      <ProjectList projects={projects} />
    </div>
  )
}
```

```tsx
// Client Component（インタラクション必要）
// components/features/projects/project-form.tsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'

export function ProjectForm() {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const router = useRouter()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)
    // 処理...
    router.push('/projects')
  }

  return <form onSubmit={handleSubmit}>...</form>
}
```

#### データフェッチングパターン

1. **Server Componentでのフェッチ（推奨）**

```tsx
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // 1時間キャッシュ
  })
  return res.json()
}

export default async function Page() {
  const data = await getData()
  return <div>{data.title}</div>
}
```

2. **Client ComponentでのSWR使用**

```tsx
'use client'

import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(r => r.json())

export function ProjectList() {
  const { data, error, isLoading } = useSWR('/api/projects', fetcher)

  if (isLoading) return <div>読み込み中...</div>
  if (error) return <div>エラーが発生しました</div>

  return <div>{/* データ表示 */}</div>
}
```

3. **Server Actionsの使用**

```tsx
// app/actions/projects.ts
'use server'

import { revalidatePath } from 'next/cache'
import { db } from '@/lib/db'

export async function createProject(formData: FormData) {
  const name = formData.get('name') as string

  await db.project.create({
    data: { name }
  })

  revalidatePath('/projects')
}
```

```tsx
// Client Component
'use client'

import { createProject } from '@/app/actions/projects'

export function ProjectForm() {
  return (
    <form action={createProject}>
      <input name="name" />
      <button type="submit">登録</button>
    </form>
  )
}
```

#### エラーハンドリング

```tsx
// app/projects/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>エラーが発生しました</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>再試行</button>
    </div>
  )
}
```

```tsx
// app/projects/loading.tsx
export default function Loading() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
    </div>
  )
}
```

### カスタムフック規約

#### 命名規則

- 必ず `use` プレフィックスで始める
- camelCaseで記述
- ファイル名はkebab-case（`use-projects.ts`）

#### カスタムフック実装パターン

```typescript
// hooks/use-projects.ts
import { useState, useEffect } from 'react'
import useSWR from 'swr'

export interface UseProjectsOptions {
  page?: number
  pageSize?: number
  status?: string
}

export function useProjects(options: UseProjectsOptions = {}) {
  const { page = 1, pageSize = 20, status } = options

  const queryParams = new URLSearchParams({
    page: String(page),
    pageSize: String(pageSize),
    ...(status && { status }),
  })

  const { data, error, isLoading, mutate } = useSWR(
    `/api/projects?${queryParams}`,
    fetcher
  )

  return {
    projects: data?.projects ?? [],
    total: data?.total ?? 0,
    isLoading,
    isError: !!error,
    error,
    refresh: mutate,
  }
}
```

```typescript
// hooks/use-auth.ts
import { useSession } from 'next-auth/react'

export function useAuth() {
  const { data: session, status } = useSession()

  return {
    user: session?.user,
    isAuthenticated: status === 'authenticated',
    isLoading: status === 'loading',
  }
}
```

```typescript
// hooks/use-form-validation.ts
import { useState } from 'react'
import { z } from 'zod'

export function useFormValidation<T extends z.ZodType>(schema: T) {
  const [errors, setErrors] = useState<Record<string, string>>({})

  const validate = (data: unknown) => {
    try {
      schema.parse(data)
      setErrors({})
      return true
    } catch (err) {
      if (err instanceof z.ZodError) {
        const formattedErrors = err.errors.reduce((acc, error) => {
          const path = error.path.join('.')
          acc[path] = error.message
          return acc
        }, {} as Record<string, string>)
        setErrors(formattedErrors)
      }
      return false
    }
  }

  return { errors, validate, clearErrors: () => setErrors({}) }
}
```

#### カスタムフック使用例

```tsx
'use client'

import { useProjects } from '@/hooks/use-projects'
import { useAuth } from '@/hooks/use-auth'

export function ProjectList() {
  const { user, isAuthenticated } = useAuth()
  const { projects, isLoading, refresh } = useProjects({
    page: 1,
    pageSize: 20,
  })

  if (!isAuthenticated) {
    return <div>ログインしてください</div>
  }

  if (isLoading) {
    return <div>読み込み中...</div>
  }

  return (
    <div>
      <button onClick={() => refresh()}>更新</button>
      {projects.map(project => (
        <div key={project.id}>{project.name}</div>
      ))}
    </div>
  )
}
```

---

## テスト標準

### Jest + React Testing Library規約

#### テストファイル配置

```
components/
├── features/
│   └── projects/
│       ├── project-form.tsx
│       └── project-form.test.tsx    # 同階層に配置

または

tests/
├── unit/
│   └── components/
│       └── project-form.test.tsx    # testsディレクトリに集約
```

#### テストファイル構成

```typescript
// components/features/projects/project-form.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { ProjectForm } from './project-form'

describe('ProjectForm', () => {
  // 各テスト前の共通セットアップ
  beforeEach(() => {
    // モックのリセット等
  })

  describe('表示', () => {
    it('プロジェクト名入力欄が表示される', () => {
      render(<ProjectForm onSubmit={jest.fn()} />)

      expect(screen.getByLabelText(/プロジェクト名/)).toBeInTheDocument()
    })

    it('必須マークが表示される', () => {
      render(<ProjectForm onSubmit={jest.fn()} />)

      expect(screen.getByText(/※プロジェクト名/)).toBeInTheDocument()
    })
  })

  describe('バリデーション', () => {
    it('プロジェクト名が未入力の場合、エラーメッセージが表示される', async () => {
      const user = userEvent.setup()
      render(<ProjectForm onSubmit={jest.fn()} />)

      const submitButton = screen.getByRole('button', { name: /登録/ })
      await user.click(submitButton)

      await waitFor(() => {
        expect(screen.getByText(/プロジェクト名は必須です/)).toBeInTheDocument()
      })
    })

    it('プロジェクト名が100文字を超える場合、エラーメッセージが表示される', async () => {
      const user = userEvent.setup()
      render(<ProjectForm onSubmit={jest.fn()} />)

      const input = screen.getByLabelText(/プロジェクト名/)
      await user.type(input, 'a'.repeat(101))

      const submitButton = screen.getByRole('button', { name: /登録/ })
      await user.click(submitButton)

      await waitFor(() => {
        expect(screen.getByText(/100文字以内/)).toBeInTheDocument()
      })
    })
  })

  describe('送信', () => {
    it('正常なデータを送信するとonSubmitが呼ばれる', async () => {
      const user = userEvent.setup()
      const mockSubmit = jest.fn()
      render(<ProjectForm onSubmit={mockSubmit} />)

      const input = screen.getByLabelText(/プロジェクト名/)
      await user.type(input, 'テストプロジェクト')

      const submitButton = screen.getByRole('button', { name: /登録/ })
      await user.click(submitButton)

      await waitFor(() => {
        expect(mockSubmit).toHaveBeenCalledWith({
          projectName: 'テストプロジェクト',
        })
      })
    })
  })
})
```

#### テストケース分類

| 分類 | 内容 | describeブロック名 |
|-----|------|------------------|
| 表示 | コンポーネントの初期表示 | `describe('表示', ...)` |
| バリデーション | 入力値検証 | `describe('バリデーション', ...)` |
| 操作 | ユーザーインタラクション | `describe('操作', ...)` |
| 送信 | フォーム送信処理 | `describe('送信', ...)` |
| 状態変化 | 状態に応じた表示変更 | `describe('状態変化', ...)` |

#### アサーション

React Testing Libraryの推奨クエリを使用。

```typescript
// 推奨クエリ（優先度順）
screen.getByRole('button', { name: /登録/ })        // アクセシビリティ重視
screen.getByLabelText(/プロジェクト名/)              // フォーム要素
screen.getByPlaceholderText(/入力してください/)      // プレースホルダー
screen.getByText(/エラーメッセージ/)                 // テキスト内容
screen.getByDisplayValue(/現在の値/)                 // 表示値

// 非推奨クエリ（避ける）
screen.getByTestId('submit-button')                 // data-testid依存
```

#### モック

```typescript
// API呼び出しのモック
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ projects: [] }),
  })
) as jest.Mock

// Next.js routerのモック
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
  }),
}))

// カスタムフックのモック
jest.mock('@/hooks/use-projects', () => ({
  useProjects: () => ({
    projects: [],
    isLoading: false,
  }),
}))
```

### Playwright E2Eテスト規約

#### テストファイル配置

```
tests/
├── e2e/
│   ├── auth/
│   │   ├── login.spec.ts
│   │   └── register.spec.ts
│   ├── projects/
│   │   ├── list.spec.ts
│   │   ├── create.spec.ts
│   │   └── edit.spec.ts
│   └── fixtures/                     # 共通フィクスチャ
│       └── auth.ts
```

#### テストコード構成

```typescript
// tests/e2e/projects/create.spec.ts
import { test, expect } from '@playwright/test'

test.describe('プロジェクト新規登録', () => {
  test.beforeEach(async ({ page }) => {
    // ログイン処理
    await page.goto('/login')
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password123')
    await page.click('button[type="submit"]')

    // プロジェクト新規登録画面へ遷移
    await page.goto('/projects/new')
  })

  test('正常系: プロジェクトを登録できる', async ({ page }) => {
    // Given: フォームに入力
    await page.fill('input[name="projectName"]', 'テストプロジェクト')
    await page.fill('input[name="startDate"]', '2025-01-01')
    await page.fill('input[name="endDate"]', '2025-12-31')

    // When: 登録ボタンをクリック
    await page.click('button:has-text("登録")')

    // Then: 一覧画面に遷移し、成功メッセージが表示される
    await expect(page).toHaveURL('/projects')
    await expect(page.locator('text=プロジェクトを登録しました')).toBeVisible()

    // Then: 登録したプロジェクトが一覧に表示される
    await expect(page.locator('text=テストプロジェクト')).toBeVisible()
  })

  test('異常系: プロジェクト名が未入力の場合、エラーが表示される', async ({ page }) => {
    // When: プロジェクト名を入力せずに登録
    await page.click('button:has-text("登録")')

    // Then: エラーメッセージが表示される
    await expect(page.locator('text=プロジェクト名は必須です')).toBeVisible()

    // Then: 画面遷移しない
    await expect(page).toHaveURL('/projects/new')
  })

  test('境界値: プロジェクト名が100文字の場合、登録できる', async ({ page }) => {
    const longName = 'あ'.repeat(100)

    await page.fill('input[name="projectName"]', longName)
    await page.fill('input[name="startDate"]', '2025-01-01')
    await page.fill('input[name="endDate"]', '2025-12-31')
    await page.click('button:has-text("登録")')

    await expect(page).toHaveURL('/projects')
    await expect(page.locator(`text=${longName}`)).toBeVisible()
  })
})
```

#### 認証フィクスチャ

```typescript
// tests/e2e/fixtures/auth.ts
import { test as base } from '@playwright/test'

export const test = base.extend({
  authenticatedPage: async ({ page }, use) => {
    // ログイン処理
    await page.goto('/login')
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password123')
    await page.click('button[type="submit"]')
    await page.waitForURL('/dashboard')

    await use(page)
  },
})

export { expect } from '@playwright/test'
```

```typescript
// 使用例
import { test, expect } from '../fixtures/auth'

test('プロジェクト一覧が表示される', async ({ authenticatedPage }) => {
  await authenticatedPage.goto('/projects')
  await expect(authenticatedPage.locator('h1')).toHaveText('プロジェクト一覧')
})
```

#### ページオブジェクトパターン

```typescript
// tests/e2e/pages/project-form.page.ts
export class ProjectFormPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/projects/new')
  }

  async fillForm(data: {
    name: string
    startDate: string
    endDate: string
  }) {
    await this.page.fill('input[name="projectName"]', data.name)
    await this.page.fill('input[name="startDate"]', data.startDate)
    await this.page.fill('input[name="endDate"]', data.endDate)
  }

  async submit() {
    await this.page.click('button:has-text("登録")')
  }

  async expectError(message: string) {
    await expect(this.page.locator(`text=${message}`)).toBeVisible()
  }
}
```

#### 視覚的回帰テスト

```typescript
test('プロジェクト一覧のスクリーンショット', async ({ page }) => {
  await page.goto('/projects')
  await expect(page).toHaveScreenshot('projects-list.png')
})
```

### テストカバレッジ要件

#### カバレッジ目標値

| 種別 | 命令カバレッジ | 分岐カバレッジ |
|-----|--------------|--------------|
| コンポーネント | 80%以上 | 70%以上 |
| カスタムフック | 90%以上 | 80%以上 |
| ユーティリティ関数 | 100% | 100% |
| API Routes | 80%以上 | 70%以上 |

#### カバレッジ測定

```bash
# 単体テスト + カバレッジ
npm run test:coverage

# カバレッジレポート確認
open coverage/lcov-report/index.html
```

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

#### カバレッジ設定

```javascript
// jest.config.js
module.exports = {
  collectCoverageFrom: [
    'app/**/*.{ts,tsx}',
    'components/**/*.{ts,tsx}',
    'lib/**/*.{ts,tsx}',
    'hooks/**/*.{ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/.next/**',
  ],
  coverageThresholds: {
    global: {
      statements: 80,
      branches: 70,
      functions: 80,
      lines: 80,
    },
  },
}
```

#### テスト対象外の許容

以下は網羅不要とする。

- Next.js自動生成ファイル（`.next/`ディレクトリ）
- 型定義のみのファイル（`.d.ts`）
- 設定ファイル（`next.config.js`等）
- Tailwind設定、Prismaスキーマ
- デバッグ用コード

---

## セキュリティ標準

### NextAuth.js認証規約

#### NextAuth設定

```typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth, { NextAuthOptions } from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { PrismaAdapter } from '@next-auth/prisma-adapter'
import { db } from '@/lib/db'
import { compare } from 'bcryptjs'

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(db),
  session: {
    strategy: 'jwt',
  },
  pages: {
    signIn: '/login',
    error: '/auth/error',
  },
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null
        }

        const user = await db.user.findUnique({
          where: { email: credentials.email },
        })

        if (!user || !user.hashedPassword) {
          return null
        }

        const isPasswordValid = await compare(
          credentials.password,
          user.hashedPassword
        )

        if (!isPasswordValid) {
          return null
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        }
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id
        token.role = user.role
      }
      return token
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string
        session.user.role = token.role as string
      }
      return session
    },
  },
}

const handler = NextAuth(authOptions)
export { handler as GET, handler as POST }
```

#### 認証ミドルウェア

```typescript
// middleware.ts
import { withAuth } from 'next-auth/middleware'

export default withAuth({
  pages: {
    signIn: '/login',
  },
})

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/projects/:path*',
    '/api/projects/:path*',
  ],
}
```

#### 認証状態確認

```typescript
// Server Component
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/[...nextauth]/route'

export default async function ProtectedPage() {
  const session = await getServerSession(authOptions)

  if (!session) {
    redirect('/login')
  }

  return <div>ようこそ、{session.user.name}さん</div>
}
```

```tsx
// Client Component
'use client'

import { useSession } from 'next-auth/react'
import { redirect } from 'next/navigation'

export function ProfileComponent() {
  const { data: session, status } = useSession()

  if (status === 'loading') {
    return <div>読み込み中...</div>
  }

  if (!session) {
    redirect('/login')
  }

  return <div>{session.user.email}</div>
}
```

#### パスワードハッシュ化

```typescript
// lib/auth.ts
import { hash, compare } from 'bcryptjs'

export async function hashPassword(password: string): Promise<string> {
  const hashedPassword = await hash(password, 12)
  return hashedPassword
}

export async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  const isValid = await compare(password, hashedPassword)
  return isValid
}
```

### API Routes セキュリティ

#### 認証チェック

```typescript
// app/api/projects/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/[...nextauth]/route'

export async function GET(request: NextRequest) {
  // 認証チェック
  const session = await getServerSession(authOptions)

  if (!session) {
    return NextResponse.json(
      { error: '認証が必要です' },
      { status: 401 }
    )
  }

  // ユーザーIDでデータフィルタリング
  const projects = await db.project.findMany({
    where: { userId: session.user.id },
  })

  return NextResponse.json({ projects })
}

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions)

  if (!session) {
    return NextResponse.json(
      { error: '認証が必要です' },
      { status: 401 }
    )
  }

  const body = await request.json()

  // バリデーション（後述）
  const validatedData = projectSchema.parse(body)

  const project = await db.project.create({
    data: {
      ...validatedData,
      userId: session.user.id,
    },
  })

  return NextResponse.json({ project }, { status: 201 })
}
```

#### 権限チェック

```typescript
// app/api/projects/[id]/route.ts
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions)

  if (!session) {
    return NextResponse.json({ error: '認証が必要です' }, { status: 401 })
  }

  // リソース所有者チェック
  const project = await db.project.findUnique({
    where: { id: params.id },
  })

  if (!project) {
    return NextResponse.json({ error: '見つかりません' }, { status: 404 })
  }

  if (project.userId !== session.user.id && session.user.role !== 'ADMIN') {
    return NextResponse.json({ error: '権限がありません' }, { status: 403 })
  }

  await db.project.delete({
    where: { id: params.id },
  })

  return NextResponse.json({ success: true })
}
```

#### レート制限

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'), // 10秒間に10リクエスト
})

export async function checkRateLimit(identifier: string) {
  const { success, limit, reset, remaining } = await ratelimit.limit(identifier)

  return { success, limit, reset, remaining }
}
```

```typescript
// app/api/projects/route.ts
export async function GET(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1'
  const { success } = await checkRateLimit(ip)

  if (!success) {
    return NextResponse.json(
      { error: 'リクエスト制限を超えました' },
      { status: 429 }
    )
  }

  // 通常処理...
}
```

### 入力値検証（Zod）

#### Zodスキーマ定義

```typescript
// lib/validations/project.ts
import { z } from 'zod'

export const projectFormSchema = z.object({
  projectName: z
    .string({ required_error: 'プロジェクト名は必須です' })
    .min(1, { message: 'プロジェクト名は必須です' })
    .max(100, { message: 'プロジェクト名は100文字以内で入力してください' }),

  startDate: z
    .string({ required_error: '開始日は必須です' })
    .datetime({ message: '開始日の形式が不正です' })
    .or(z.date()),

  endDate: z
    .string({ required_error: '終了日は必須です' })
    .datetime({ message: '終了日の形式が不正です' })
    .or(z.date()),

  budget: z
    .number({ invalid_type_error: '予算は数値で入力してください' })
    .min(0, { message: '予算は0以上で入力してください' })
    .max(999999999, { message: '予算は999,999,999以内で入力してください' })
    .optional(),

  status: z.enum(['active', 'completed', 'cancelled'], {
    errorMap: () => ({ message: 'ステータスが不正です' }),
  }),

  email: z
    .string()
    .email({ message: 'メールアドレスの形式が不正です' })
    .optional(),

  postalCode: z
    .string()
    .regex(/^\d{3}-\d{4}$/, {
      message: '郵便番号はXXX-XXXX形式で入力してください',
    })
    .optional(),
}).refine(
  (data) => {
    const start = new Date(data.startDate)
    const end = new Date(data.endDate)
    return start <= end
  },
  {
    message: '開始日は終了日より前の日付を入力してください',
    path: ['startDate'],
  }
)

export type ProjectFormData = z.infer<typeof projectFormSchema>
```

#### react-hook-formとの統合

```tsx
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { projectFormSchema, ProjectFormData } from '@/lib/validations/project'

export function ProjectForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<ProjectFormData>({
    resolver: zodResolver(projectFormSchema),
  })

  const onSubmit = async (data: ProjectFormData) => {
    const res = await fetch('/api/projects', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    })

    if (!res.ok) {
      const error = await res.json()
      // エラーハンドリング
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>※プロジェクト名</label>
        <input {...register('projectName')} />
        {errors.projectName && (
          <p className="text-red-500">{errors.projectName.message}</p>
        )}
      </div>

      <button type="submit" disabled={isSubmitting}>
        登録
      </button>
    </form>
  )
}
```

#### API Routesでのバリデーション

```typescript
// app/api/projects/route.ts
import { projectFormSchema } from '@/lib/validations/project'
import { NextRequest, NextResponse } from 'next/server'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // Zodでバリデーション
    const validatedData = projectFormSchema.parse(body)

    // データベース保存処理
    const project = await db.project.create({
      data: validatedData,
    })

    return NextResponse.json({ project }, { status: 201 })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: '入力内容にエラーがあります',
          details: error.errors,
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: 'サーバーエラーが発生しました' },
      { status: 500 }
    )
  }
}
```

#### Server Actionsでのバリデーション

```typescript
// app/actions/projects.ts
'use server'

import { revalidatePath } from 'next/cache'
import { projectFormSchema } from '@/lib/validations/project'
import { getServerSession } from 'next-auth'

export async function createProject(formData: FormData) {
  const session = await getServerSession()

  if (!session) {
    return { error: '認証が必要です' }
  }

  try {
    const rawData = {
      projectName: formData.get('projectName'),
      startDate: formData.get('startDate'),
      endDate: formData.get('endDate'),
    }

    const validatedData = projectFormSchema.parse(rawData)

    await db.project.create({
      data: {
        ...validatedData,
        userId: session.user.id,
      },
    })

    revalidatePath('/projects')
    return { success: true }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        error: '入力内容にエラーがあります',
        details: error.errors,
      }
    }

    return { error: 'エラーが発生しました' }
  }
}
```

### XSS対策

#### Reactの自動エスケープ

Reactは標準でXSS対策が組み込まれている。

```tsx
// 安全（自動エスケープ）
const userInput = '<script>alert("XSS")</script>'
<div>{userInput}</div>
// 出力: &lt;script&gt;alert("XSS")&lt;/script&gt;
```

#### dangerouslySetInnerHTMLの使用制限

```tsx
// 危険（使用禁止）
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// 許可する場合はサニタイズ必須
import DOMPurify from 'isomorphic-dompurify'

const sanitizedHtml = DOMPurify.sanitize(userInput)
<div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />
```

#### Content Security Policy設定

```typescript
// next.config.js
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline';
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: https:;
      font-src 'self';
      connect-src 'self';
    `
      .replace(/\s{2,}/g, ' ')
      .trim(),
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY',
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block',
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin',
  },
]

module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: securityHeaders,
      },
    ]
  },
}
```

#### リッチテキスト対応

```tsx
'use client'

import dynamic from 'next/dynamic'
import DOMPurify from 'isomorphic-dompurify'

const RichTextEditor = dynamic(() => import('@/components/rich-text-editor'), {
  ssr: false,
})

export function ContentEditor() {
  const [content, setContent] = useState('')

  const handleSave = async () => {
    // ホワイトリスト方式でサニタイズ
    const sanitizedContent = DOMPurify.sanitize(content, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a', 'ul', 'ol', 'li'],
      ALLOWED_ATTR: ['href', 'target', 'rel'],
    })

    await fetch('/api/content', {
      method: 'POST',
      body: JSON.stringify({ content: sanitizedContent }),
    })
  }

  return (
    <div>
      <RichTextEditor value={content} onChange={setContent} />
      <button onClick={handleSave}>保存</button>
    </div>
  )
}
```

#### CSRF対策

Next.jsではServer ActionsやAPI Routesで自動的にCSRF対策が適用される。

```tsx
// Server Actions（自動CSRF保護）
'use server'

export async function updateProject(formData: FormData) {
  // CSRFトークンは自動検証される
  // 処理...
}
```

```tsx
// Client Component
'use client'

export function ProjectForm() {
  return (
    <form action={updateProject}>
      {/* CSRFトークンは自動付与される */}
      <input name="projectName" />
      <button type="submit">更新</button>
    </form>
  )
}
```

---

## 改訂履歴

| 版数 | 改訂日 | 改訂内容 | 改訂者 |
|-----|--------|---------|--------|
| 1.0 | 2025-11-27 | 初版作成（Spring Boot版） | - |
| 2.0 | 2025-11-27 | Next.js版に全面改訂 | - |

---

## 補足事項

### 本標準の適用範囲

- サンプルプロジェクトのすべてのNext.js開発作業に適用
- A1（プロジェクト管理システム）、B1（顧客管理システム）共通

### 標準の改訂

- 新たな技術要素の追加や改善提案がある場合は、プロジェクトリーダーに報告
- 定期的に見直しを実施し、最新のベストプラクティスを反映

### 参考資料

- [Next.js公式ドキュメント](https://nextjs.org/docs)
- [React公式ドキュメント](https://react.dev/)
- [TypeScript公式ドキュメント](https://www.typescriptlang.org/docs/)
- [Tailwind CSS公式ドキュメント](https://tailwindcss.com/docs)
- [shadcn/ui](https://ui.shadcn.com/)
- [NextAuth.js](https://next-auth.js.org/)
- [Zod](https://zod.dev/)
- [React Testing Library](https://testing-library.com/react)
- [Playwright](https://playwright.dev/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
