# セキュリティ対応表

## 1. セキュリティ要件一覧

### 1.1 OWASP Top 10 対応状況

| 脅威 | 脅威内容 | 対策状況 | 実装方法 |
|------|----------|----------|----------|
| A01:2021 アクセス制御の不備 | 認証・認可の不適切な実装 | ✅ 対応済 | NextAuth.js + Middleware による認証・認可制御 |
| A02:2021 暗号化の失敗 | 機密データの暗号化不足 | ✅ 対応済 | HTTPS通信、bcrypt パスワードハッシュ化、環境変数暗号化 |
| A03:2021 インジェクション | SQLインジェクション等 | ✅ 対応済 | Prisma パラメータ化クエリ、Zodバリデーション |
| A04:2021 安全が確認されない不安全な設計 | セキュリティ要件の設計不足 | ✅ 対応済 | セキュリティ設計レビュー実施 |
| A05:2021 セキュリティの設定ミス | デフォルト設定の使用 | ✅ 対応済 | 環境別設定ファイル、セキュリティヘッダ設定 |
| A06:2021 脆弱で古いコンポーネント | 脆弱性のあるライブラリ使用 | ✅ 対応済 | 定期的な依存関係更新、npm audit |
| A07:2021 識別と認証の失敗 | 認証機能の脆弱性 | ✅ 対応済 | NextAuth.js セッション管理、アカウントロック機能 |
| A08:2021 ソフトウェアとデータの整合性の不具合 | データ改ざん | ✅ 対応済 | CSRF対策(Server Actions built-in)、署名検証 |
| A09:2021 セキュリティログとモニタリングの失敗 | ログ記録不足 | ✅ 対応済 | 認証・認可イベントのログ記録(Winston/Pino) |
| A10:2021 サーバサイドリクエストフォージェリ | SSRF攻撃 | ✅ 対応済 | 外部リクエストの制限、URL検証 |

### 1.2 主要セキュリティ対策

#### 1.2.1 SQLインジェクション対策
- **実装方法**: Prisma ORM パラメータ化クエリ
- **対策内容**:
  - Prismaの型安全なクエリビルダー使用
  - プリペアドステートメントによる自動エスケープ
  - 生SQLの使用禁止(必要な場合は `$queryRaw` + パラメータ化)

```typescript
// ✅ 安全な実装例
const user = await prisma.user.findUnique({
  where: { id: userId }
});

// ✅ 動的クエリも安全
const users = await prisma.user.findMany({
  where: {
    email: { contains: searchTerm }
  }
});

// ✅ 生SQLが必要な場合(パラメータ化必須)
const result = await prisma.$queryRaw`
  SELECT * FROM users WHERE id = ${userId}
`;

// ❌ 危険な実装(使用禁止)
// const query = `SELECT * FROM users WHERE id = ${userId}`;
// await prisma.$queryRawUnsafe(query);
```

#### 1.2.2 XSS(クロスサイトスクリプティング)対策
- **実装方法**: React 自動エスケープ + DOMPurify
- **対策内容**:
  - Reactのデフォルト自動エスケープ機能
  - `dangerouslySetInnerHTML` の使用制限
  - Server Components での安全なデータレンダリング
  - ユーザー入力の厳格なサニタイズ

```tsx
// ✅ 安全な実装例(React自動エスケープ)
export default function UserProfile({ name }: { name: string }) {
  return <div>{name}</div>; // 自動エスケープ
}

// ✅ HTMLが必要な場合(DOMPurify使用)
import DOMPurify from 'isomorphic-dompurify';

export default function RichContent({ html }: { html: string }) {
  const sanitized = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    ALLOWED_ATTR: []
  });

  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}

// ❌ 危険な実装(使用禁止)
// <div dangerouslySetInnerHTML={{ __html: userInput }} />
```

#### 1.2.3 CSRF(クロスサイトリクエストフォージェリ)対策
- **実装方法**: Next.js Server Actions + SameSite Cookie
- **対策内容**:
  - Server Actionsの組み込みCSRF保護
  - SameSite=Lax/Strict Cookie属性
  - Origin/Referrerヘッダー検証
  - API RoutesでのCSRFトークン検証

```typescript
// ✅ Server Actions(自動CSRF保護)
'use server';

export async function createUser(formData: FormData) {
  // Next.js が自動的にCSRF検証を実行
  const name = formData.get('name') as string;

  const user = await prisma.user.create({
    data: { name }
  });

  return user;
}

// ✅ API Routes(手動CSRF検証)
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  // Originヘッダー検証
  const origin = request.headers.get('origin');
  const allowedOrigins = [process.env.NEXT_PUBLIC_APP_URL];

  if (!origin || !allowedOrigins.includes(origin)) {
    return NextResponse.json({ error: 'Invalid origin' }, { status: 403 });
  }

  // 処理続行
  const data = await request.json();
  // ...
}

// next.config.js でのCookie設定
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Set-Cookie',
            value: 'SameSite=Strict; Secure; HttpOnly'
          }
        ]
      }
    ];
  }
};
```

#### 1.2.4 認証・認可
- **実装方法**: NextAuth.js v5 (Auth.js)
- **対策内容**:
  - JWTまたはDatabase Sessionによる認証
  - bcryptによるパスワードハッシュ化
  - ロールベースアクセス制御(RBAC)
  - Middlewareによる認証・認可チェック
  - セッション管理とタイムアウト

## 2. 画面別・API別セキュリティ対応

### 2.1 画面機能セキュリティマトリックス

| 機能ID | 機能名 | 認証 | 認可 | 入力検証 | 出力エスケープ | CSRF対策 | コンポーネントタイプ | 備考 |
|--------|--------|------|------|----------|----------------|----------|-------------------|------|
| A1-1 | ユーザー登録画面 | 不要 | - | ✅ | ✅ | ✅ | Server Component | 公開画面 |
| A1-2 | ユーザー登録確認画面 | 不要 | - | ✅ | ✅ | ✅ | Server Component | |
| A1-3 | ユーザー登録完了画面 | 不要 | - | - | ✅ | - | Server Component | |
| A2-1 | ユーザー一覧画面 | ✅ | ADMIN | ✅ | ✅ | - | Server Component | 管理者のみ |
| A3-1 | ユーザー詳細画面 | ✅ | ADMIN | ✅ | ✅ | - | Server Component | 管理者のみ |
| A4-1 | ユーザー更新画面 | ✅ | ADMIN | ✅ | ✅ | ✅ | Client Component | 管理者のみ |
| A4-2 | ユーザー更新確認画面 | ✅ | ADMIN | ✅ | ✅ | ✅ | Server Component | |
| A4-3 | ユーザー更新完了画面 | ✅ | ADMIN | - | ✅ | - | Server Component | |
| A5-1 | ユーザー削除確認画面 | ✅ | ADMIN | ✅ | ✅ | ✅ | Server Component | 管理者のみ |
| A5-2 | ユーザー削除完了画面 | ✅ | ADMIN | - | ✅ | - | Server Component | |
| - | ログイン画面 | 不要 | - | ✅ | ✅ | ✅ | Client Component | |
| - | ログアウト | ✅ | - | - | - | ✅ | Server Action | |

### 2.2 API セキュリティマトリックス

| 機能ID | API エンドポイント | メソッド | 認証 | 認可 | 入力検証 | レート制限 | 実装方式 | 備考 |
|--------|-------------------|----------|------|------|----------|-----------|---------|------|
| B1-1 | /api/users | GET | ✅ | ADMIN | ✅ | ✅ | Route Handler | 一覧取得 |
| B1-2 | /api/users/[id] | GET | ✅ | ADMIN | ✅ | ✅ | Route Handler | 詳細取得 |
| B1-3 | /api/users | POST | ✅ | ADMIN | ✅ | ✅ | Route Handler | 新規作成 |
| B1-4 | /api/users/[id] | PUT | ✅ | ADMIN | ✅ | ✅ | Route Handler | 更新 |
| B1-5 | /api/users/[id] | DELETE | ✅ | ADMIN | ✅ | ✅ | Route Handler | 削除 |
| B2-1 | createUserAction | - | ✅ | ADMIN | ✅ | - | Server Action | 作成アクション |
| B2-2 | updateUserAction | - | ✅ | ADMIN | ✅ | - | Server Action | 更新アクション |
| B2-3 | deleteUserAction | - | ✅ | ADMIN | ✅ | - | Server Action | 削除アクション |

### 2.3 Middleware認証チェック実装

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { auth } from '@/auth';

export async function middleware(request: NextRequest) {
  const session = await auth();
  const { pathname } = request.nextUrl;

  // 公開パス
  const publicPaths = ['/', '/login', '/users/register'];
  if (publicPaths.some(path => pathname.startsWith(path))) {
    return NextResponse.next();
  }

  // 認証チェック
  if (!session?.user) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // 管理者専用パスの認可チェック
  const adminPaths = ['/users/list', '/users/detail', '/users/update', '/users/delete', '/api'];
  if (adminPaths.some(path => pathname.startsWith(path))) {
    if (session.user.role !== 'ADMIN') {
      return NextResponse.redirect(new URL('/unauthorized', request.url));
    }
  }

  // セキュリティヘッダー追加
  const response = NextResponse.next();
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set(
    'Content-Security-Policy',
    "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
  );

  return response;
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|public).*)',
  ],
};
```

## 3. 認証・認可設計

### 3.1 NextAuth.js 設定

#### 3.1.1 認証設定ファイル

```typescript
// auth.ts
import NextAuth, { type DefaultSession } from 'next-auth';
import Credentials from 'next-auth/providers/credentials';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';
import { z } from 'zod';

// セッション型拡張
declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
      role: 'ADMIN' | 'USER' | 'GUEST';
    } & DefaultSession['user'];
  }

  interface User {
    role: 'ADMIN' | 'USER' | 'GUEST';
  }
}

// ログイン認証スキーマ
const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

export const { auth, handlers, signIn, signOut } = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: 'jwt',
    maxAge: 30 * 60, // 30分
  },
  pages: {
    signIn: '/login',
    error: '/login',
  },
  providers: [
    Credentials({
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      authorize: async (credentials) => {
        try {
          const { email, password } = loginSchema.parse(credentials);

          // ユーザー検索
          const user = await prisma.user.findUnique({
            where: { email },
            select: {
              id: true,
              email: true,
              name: true,
              password: true,
              role: true,
              loginAttempts: true,
              lockedUntil: true,
            },
          });

          if (!user) {
            return null;
          }

          // アカウントロックチェック
          if (user.lockedUntil && user.lockedUntil > new Date()) {
            throw new Error('アカウントがロックされています');
          }

          // パスワード検証
          const isValid = await bcrypt.compare(password, user.password);

          if (!isValid) {
            // ログイン失敗回数をインクリメント
            const attempts = (user.loginAttempts || 0) + 1;
            const lockDuration = 30 * 60 * 1000; // 30分

            await prisma.user.update({
              where: { id: user.id },
              data: {
                loginAttempts: attempts,
                lockedUntil: attempts >= 5
                  ? new Date(Date.now() + lockDuration)
                  : null,
              },
            });

            return null;
          }

          // ログイン成功 - 試行回数リセット
          await prisma.user.update({
            where: { id: user.id },
            data: {
              loginAttempts: 0,
              lockedUntil: null,
              lastLoginAt: new Date(),
            },
          });

          return {
            id: user.id,
            email: user.email,
            name: user.name,
            role: user.role,
          };
        } catch (error) {
          console.error('Authentication error:', error);
          return null;
        }
      },
    }),
  ],
  callbacks: {
    jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as 'ADMIN' | 'USER' | 'GUEST';
      }
      return session;
    },
  },
  events: {
    async signIn({ user }) {
      console.log(`[AUTH] Login successful - User: ${user.email}`);
    },
    async signOut({ token }) {
      console.log(`[AUTH] Logout - User: ${token?.email}`);
    },
  },
});
```

#### 3.1.2 ログイン認証フロー

```
1. ユーザーがログイン画面でメールアドレスとパスワードを入力
   ↓
2. Credentials Provider が認証処理を実行
   ↓
3. Prisma でDBからユーザー情報を取得
   ↓
4. アカウントロック状態をチェック
   ↓
5. bcrypt でパスワードをハッシュ化し検証
   ↓
6. 認証成功 → JWT生成、トップページへリダイレクト
   認証失敗 → ログイン失敗回数カウント、エラーメッセージ表示
   ↓
7. JWT をHTTPOnly Cookieに保存
```

### 3.2 パスワードポリシー

| 項目 | 要件 |
|------|------|
| 最小文字数 | 8文字 |
| 最大文字数 | 100文字 |
| 文字種要件 | 英大文字、英小文字、数字、記号をそれぞれ1文字以上 |
| 使用可能記号 | `@$!%*?&` |
| ハッシュアルゴリズム | bcrypt (saltRounds=10) |
| パスワード有効期限 | 90日(推奨) |
| パスワード履歴 | 過去3世代の再使用を禁止(推奨) |

### 3.3 セッション管理

| 項目 | 設定値 | 備考 |
|------|--------|------|
| セッションタイムアウト | 30分 | JWT maxAge設定 |
| セッション保存方式 | JWT | または Database Session |
| Cookie名 | `authjs.session-token` | NextAuth.js デフォルト |
| Cookie属性 | HttpOnly, Secure, SameSite=Lax | XSS/CSRF対策 |
| 同時セッション数 | 制限なし | 必要に応じてDB管理 |
| トークン更新 | 自動更新 | アクティブセッション延長 |

### 3.4 ロールベースアクセス制御(RBAC)

#### 3.4.1 ロール定義

```typescript
// types/auth.ts
export enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  GUEST = 'GUEST',
}

export type RolePermissions = {
  [key in UserRole]: string[];
};

export const permissions: RolePermissions = {
  ADMIN: ['users:read', 'users:write', 'users:delete', 'api:access'],
  USER: ['users:read'],
  GUEST: ['public:access'],
};
```

#### 3.4.2 機能別アクセス権限

| 機能 | GUEST | USER | ADMIN |
|------|-------|------|-------|
| ユーザー登録(A1) | ✅ | ✅ | ✅ |
| ユーザー一覧(A2) | ❌ | ❌ | ✅ |
| ユーザー詳細(A3) | ❌ | ❌ | ✅ |
| ユーザー更新(A4) | ❌ | ❌ | ✅ |
| ユーザー削除(A5) | ❌ | ❌ | ✅ |
| API アクセス(B1) | ❌ | ❌ | ✅ |

#### 3.4.3 認可ヘルパー関数

```typescript
// lib/auth-utils.ts
import { auth } from '@/auth';
import { redirect } from 'next/navigation';
import { UserRole } from '@/types/auth';

/**
 * Server Componentで認証必須チェック
 */
export async function requireAuth() {
  const session = await auth();
  if (!session?.user) {
    redirect('/login');
  }
  return session;
}

/**
 * Server Componentで管理者権限チェック
 */
export async function requireAdmin() {
  const session = await requireAuth();
  if (session.user.role !== UserRole.ADMIN) {
    redirect('/unauthorized');
  }
  return session;
}

/**
 * ロール判定
 */
export async function hasRole(role: UserRole): Promise<boolean> {
  const session = await auth();
  return session?.user?.role === role;
}

/**
 * 権限判定
 */
export async function hasPermission(permission: string): Promise<boolean> {
  const session = await auth();
  if (!session?.user) return false;

  const userPermissions = permissions[session.user.role];
  return userPermissions.includes(permission);
}
```

#### 3.4.4 Server Component での使用例

```typescript
// app/users/list/page.tsx
import { requireAdmin } from '@/lib/auth-utils';
import { prisma } from '@/lib/prisma';

export default async function UserListPage() {
  // 管理者権限チェック
  await requireAdmin();

  // データ取得
  const users = await prisma.user.findMany({
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
    },
  });

  return (
    <div>
      <h1>ユーザー一覧</h1>
      {/* ユーザー一覧表示 */}
    </div>
  );
}
```

#### 3.4.5 API Route での認可実装

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  // 認証チェック
  const session = await auth();
  if (!session?.user) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  // 認可チェック
  if (session.user.role !== 'ADMIN') {
    return NextResponse.json(
      { error: 'Forbidden' },
      { status: 403 }
    );
  }

  // データ取得
  const users = await prisma.user.findMany();

  return NextResponse.json(users);
}
```

### 3.5 アカウントロック機能

| 項目 | 設定値 | 備考 |
|------|--------|------|
| ログイン試行回数上限 | 5回 | 連続失敗回数 |
| ロック期間 | 30分 | 自動解除 |
| ロック解除方法 | 時間経過 or 管理者操作 | |
| 試行回数リセット | ログイン成功時 | |

## 4. 入力検証ルール

### 4.1 Zodスキーマバリデーション

#### 4.1.1 共通バリデーションスキーマ

```typescript
// lib/validations/common.ts
import { z } from 'zod';

/**
 * 日本語全角文字パターン
 */
export const fullWidthJapanese = z
  .string()
  .regex(/^[ぁ-んァ-ヶー一-龠々]+$/, '全角文字で入力してください');

/**
 * 全角カタカナパターン
 */
export const fullWidthKatakana = z
  .string()
  .regex(/^[ァ-ヶー]+$/, '全角カタカナで入力してください');

/**
 * パスワードパターン
 */
export const passwordPattern = z
  .string()
  .min(8, 'パスワードは8文字以上で入力してください')
  .max(100, 'パスワードは100文字以内で入力してください')
  .regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$/,
    'パスワードは英大文字、英小文字、数字、記号をそれぞれ1文字以上含めてください'
  );

/**
 * メールアドレスパターン
 */
export const emailPattern = z
  .string()
  .email('メールアドレスの形式が正しくありません')
  .max(100, 'メールアドレスは100文字以内で入力してください');

/**
 * 電話番号パターン(ハイフンなし)
 */
export const phonePattern = z
  .string()
  .regex(/^0\d{9,10}$/, '電話番号は10桁または11桁の数字で入力してください');

/**
 * 郵便番号パターン(ハイフンなし)
 */
export const postalCodePattern = z
  .string()
  .regex(/^\d{7}$/, '郵便番号は7桁の数字で入力してください');
```

#### 4.1.2 ユーザー情報バリデーション

```typescript
// lib/validations/user.ts
import { z } from 'zod';
import {
  fullWidthJapanese,
  fullWidthKatakana,
  passwordPattern,
  emailPattern,
  phonePattern,
  postalCodePattern,
} from './common';

/**
 * ユーザー登録スキーマ
 */
export const userRegisterSchema = z.object({
  lastName: fullWidthJapanese
    .min(1, '姓は必須です')
    .max(20, '姓は20文字以内で入力してください'),

  firstName: fullWidthJapanese
    .min(1, '名は必須です')
    .max(20, '名は20文字以内で入力してください'),

  lastNameKana: fullWidthKatakana
    .min(1, '姓(カナ)は必須です')
    .max(20, '姓(カナ)は20文字以内で入力してください'),

  firstNameKana: fullWidthKatakana
    .min(1, '名(カナ)は必須です')
    .max(20, '名(カナ)は20文字以内で入力してください'),

  email: emailPattern,

  password: passwordPattern,

  passwordConfirmation: z.string(),

  phoneNumber: phonePattern,

  postalCode: postalCodePattern,

  address: z
    .string()
    .min(1, '住所は必須です')
    .max(200, '住所は200文字以内で入力してください'),

  gender: z.enum(['0', '1', '2'], {
    errorMap: () => ({ message: '性別を選択してください' }),
  }),

  dateOfBirth: z
    .string()
    .or(z.date())
    .refine(
      (date) => {
        const d = new Date(date);
        return d < new Date();
      },
      { message: '生年月日は過去の日付を入力してください' }
    ),
}).refine(
  (data) => data.password === data.passwordConfirmation,
  {
    message: 'パスワードが一致しません',
    path: ['passwordConfirmation'],
  }
);

/**
 * ユーザー更新スキーマ(パスワードは任意)
 */
export const userUpdateSchema = userRegisterSchema
  .omit({ password: true, passwordConfirmation: true })
  .extend({
    password: passwordPattern.optional(),
    passwordConfirmation: z.string().optional(),
  })
  .refine(
    (data) => {
      if (data.password || data.passwordConfirmation) {
        return data.password === data.passwordConfirmation;
      }
      return true;
    },
    {
      message: 'パスワードが一致しません',
      path: ['passwordConfirmation'],
    }
  );

export type UserRegisterInput = z.infer<typeof userRegisterSchema>;
export type UserUpdateInput = z.infer<typeof userUpdateSchema>;
```

### 4.2 項目別検証ルール

| 項目名 | 物理名 | 必須 | 型 | 最小長 | 最大長 | 形式 | 備考 |
|--------|--------|------|----|----|-------|------|------|
| ユーザーID | userId | - | 文字列 | - | - | UUID/CUID | 自動生成 |
| 姓(漢字) | lastName | ✅ | 文字列 | 1 | 20 | 全角文字 | |
| 名(漢字) | firstName | ✅ | 文字列 | 1 | 20 | 全角文字 | |
| 姓(カナ) | lastNameKana | ✅ | 文字列 | 1 | 20 | 全角カタカナ | |
| 名(カナ) | firstNameKana | ✅ | 文字列 | 1 | 20 | 全角カタカナ | |
| メールアドレス | email | ✅ | 文字列 | 5 | 100 | RFC 5322準拠 | 一意制約 |
| パスワード | password | ✅ | 文字列 | 8 | 100 | 英数字記号混在 | bcryptハッシュ化 |
| 電話番号 | phoneNumber | ✅ | 文字列 | 10 | 11 | 数字のみ | ハイフンなし |
| 郵便番号 | postalCode | ✅ | 文字列 | 7 | 7 | 数字のみ | ハイフンなし |
| 住所 | address | ✅ | 文字列 | 1 | 200 | - | |
| 性別 | gender | ✅ | 文字列 | 1 | 1 | 0:男性, 1:女性, 2:その他 | |
| 生年月日 | dateOfBirth | ✅ | 日付 | - | - | ISO 8601 | 過去日のみ |

### 4.3 Server-side バリデーション

#### 4.3.1 Server Action でのバリデーション

```typescript
// app/actions/user.ts
'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { prisma } from '@/lib/prisma';
import { userRegisterSchema, type UserRegisterInput } from '@/lib/validations/user';
import { requireAdmin } from '@/lib/auth-utils';
import bcrypt from 'bcryptjs';

export async function createUser(input: UserRegisterInput) {
  // 管理者権限チェック
  await requireAdmin();

  try {
    // バリデーション
    const validated = userRegisterSchema.parse(input);

    // メールアドレス重複チェック
    const existing = await prisma.user.findUnique({
      where: { email: validated.email },
    });

    if (existing) {
      return {
        success: false,
        error: 'このメールアドレスは既に登録されています',
      };
    }

    // パスワードハッシュ化
    const hashedPassword = await bcrypt.hash(validated.password, 10);

    // ユーザー作成
    await prisma.user.create({
      data: {
        lastName: validated.lastName,
        firstName: validated.firstName,
        lastNameKana: validated.lastNameKana,
        firstNameKana: validated.firstNameKana,
        email: validated.email,
        password: hashedPassword,
        phoneNumber: validated.phoneNumber,
        postalCode: validated.postalCode,
        address: validated.address,
        gender: validated.gender,
        dateOfBirth: new Date(validated.dateOfBirth),
        role: 'USER',
      },
    });

    // キャッシュ再検証
    revalidatePath('/users/list');

    return { success: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: '入力内容に誤りがあります',
        fieldErrors: error.flatten().fieldErrors,
      };
    }

    console.error('User creation error:', error);
    return {
      success: false,
      error: 'ユーザー登録に失敗しました',
    };
  }
}
```

### 4.4 Client-side バリデーション

#### 4.4.1 React Hook Form with Zod

```typescript
// components/UserForm.tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { userRegisterSchema, type UserRegisterInput } from '@/lib/validations/user';
import { createUser } from '@/app/actions/user';
import { useState } from 'react';

export function UserForm() {
  const [serverError, setServerError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<UserRegisterInput>({
    resolver: zodResolver(userRegisterSchema),
    mode: 'onBlur',
  });

  const onSubmit = async (data: UserRegisterInput) => {
    setServerError(null);

    const result = await createUser(data);

    if (!result.success) {
      setServerError(result.error || 'エラーが発生しました');
    } else {
      // 成功時の処理
      window.location.href = '/users/list';
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      {serverError && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          {serverError}
        </div>
      )}

      {/* 姓 */}
      <div>
        <label htmlFor="lastName" className="block text-sm font-medium">
          姓 <span className="text-red-500">*</span>
        </label>
        <input
          id="lastName"
          type="text"
          {...register('lastName')}
          className="mt-1 block w-full rounded border-gray-300"
        />
        {errors.lastName && (
          <p className="mt-1 text-sm text-red-600">{errors.lastName.message}</p>
        )}
      </div>

      {/* 名 */}
      <div>
        <label htmlFor="firstName" className="block text-sm font-medium">
          名 <span className="text-red-500">*</span>
        </label>
        <input
          id="firstName"
          type="text"
          {...register('firstName')}
          className="mt-1 block w-full rounded border-gray-300"
        />
        {errors.firstName && (
          <p className="mt-1 text-sm text-red-600">{errors.firstName.message}</p>
        )}
      </div>

      {/* メールアドレス */}
      <div>
        <label htmlFor="email" className="block text-sm font-medium">
          メールアドレス <span className="text-red-500">*</span>
        </label>
        <input
          id="email"
          type="email"
          {...register('email')}
          className="mt-1 block w-full rounded border-gray-300"
        />
        {errors.email && (
          <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
        )}
      </div>

      {/* パスワード */}
      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          パスワード <span className="text-red-500">*</span>
        </label>
        <input
          id="password"
          type="password"
          {...register('password')}
          className="mt-1 block w-full rounded border-gray-300"
        />
        {errors.password && (
          <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
        )}
      </div>

      {/* パスワード確認 */}
      <div>
        <label htmlFor="passwordConfirmation" className="block text-sm font-medium">
          パスワード(確認) <span className="text-red-500">*</span>
        </label>
        <input
          id="passwordConfirmation"
          type="password"
          {...register('passwordConfirmation')}
          className="mt-1 block w-full rounded border-gray-300"
        />
        {errors.passwordConfirmation && (
          <p className="mt-1 text-sm text-red-600">{errors.passwordConfirmation.message}</p>
        )}
      </div>

      {/* 送信ボタン */}
      <button
        type="submit"
        disabled={isSubmitting}
        className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-gray-400"
      >
        {isSubmitting ? '登録中...' : '登録'}
      </button>
    </form>
  );
}
```

## 5. セキュアコーディング規約

### 5.1 禁止事項

| 禁止内容 | 理由 | 代替方法 |
|---------|------|----------|
| 生SQLの文字列連結 | SQLインジェクション | Prisma クエリビルダー |
| `$queryRawUnsafe` の使用 | SQLインジェクション | `$queryRaw` + パラメータ化 |
| `dangerouslySetInnerHTML` の無制限使用 | XSS脆弱性 | React自動エスケープ or DOMPurify |
| パスワードの平文保存 | 情報漏洩 | bcrypt ハッシュ化 |
| 環境変数のクライアント露出 | 情報漏洩 | `NEXT_PUBLIC_` 以外はサーバー専用 |
| ハードコードされたシークレット | 情報漏洩 | `.env.local` + 環境変数 |
| `eval()`, `Function()` の使用 | コードインジェクション | 安全な代替実装 |
| セキュリティヘッダの無効化 | 各種攻撃のリスク | next.config.js で適切に設定 |

### 5.2 推奨事項

| 推奨内容 | 理由 | 実装方法 |
|---------|------|----------|
| 入力値の検証 | 不正データ防止 | Zod スキーマバリデーション |
| 出力のエスケープ | XSS対策 | React自動エスケープ(デフォルト) |
| HTTPS通信 | 盗聴防止 | 本番環境でSSL/TLS必須 |
| セキュリティヘッダ設定 | 各種攻撃対策 | next.config.js設定 |
| ログ記録 | 監査証跡 | 認証・認可イベントを記録 |
| 最小権限の原則 | 権限昇格防止 | 必要最小限の権限付与 |
| Server Components優先 | セキュリティ強化 | データ取得はServer Side |
| API Rate Limiting | DoS攻撃対策 | next-rate-limit等使用 |

### 5.3 Next.js セキュリティベストプラクティス

```typescript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  // セキュリティヘッダー設定
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-DNS-Prefetch-Control',
            value: 'on'
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=63072000; includeSubDomains; preload'
          },
          {
            key: 'X-Frame-Options',
            value: 'SAMEORIGIN'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block'
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin'
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()'
          },
          {
            key: 'Content-Security-Policy',
            value: `
              default-src 'self';
              script-src 'self' 'unsafe-eval' 'unsafe-inline';
              style-src 'self' 'unsafe-inline';
              img-src 'self' data: https:;
              font-src 'self';
              connect-src 'self';
              frame-ancestors 'self';
            `.replace(/\s{2,}/g, ' ').trim()
          }
        ]
      }
    ];
  },

  // 環境変数検証
  env: {
    // クライアント公開用のみ NEXT_PUBLIC_ プレフィックス
  },

  // 本番最適化
  reactStrictMode: true,
  poweredByHeader: false, // X-Powered-By ヘッダー削除
};

module.exports = nextConfig;
```

## 6. ログ・監査

### 6.1 セキュリティイベントログ

| イベント | ログレベル | 記録内容 | 保管期間 |
|---------|-----------|----------|----------|
| ログイン成功 | INFO | ユーザーID、IPアドレス、タイムスタンプ | 1年 |
| ログイン失敗 | WARN | メールアドレス、IPアドレス、理由、タイムスタンプ | 1年 |
| ログアウト | INFO | ユーザーID、タイムスタンプ | 1年 |
| アカウントロック | WARN | ユーザーID、IPアドレス、タイムスタンプ | 1年 |
| 権限エラー | ERROR | ユーザーID、要求URL、タイムスタンプ | 1年 |
| データ更新 | INFO | ユーザーID、操作内容、対象ID、タイムスタンプ | 1年 |
| データ削除 | WARN | ユーザーID、削除内容、対象ID、タイムスタンプ | 1年 |
| 例外発生 | ERROR | ユーザーID、例外内容、スタックトレース | 1年 |

### 6.2 ログ出力実装例

#### 6.2.1 Pino ロガー設定

```typescript
// lib/logger.ts
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  formatters: {
    level: (label) => {
      return { level: label.toUpperCase() };
    },
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  redact: {
    paths: ['password', 'token', 'authorization'],
    remove: true,
  },
});

// セキュリティイベント専用ロガー
export const securityLogger = logger.child({ module: 'security' });
```

#### 6.2.2 ログ記録例

```typescript
// auth.ts (NextAuth.js events)
import { securityLogger } from '@/lib/logger';

export const { auth, handlers, signIn, signOut } = NextAuth({
  // ... 他の設定
  events: {
    async signIn({ user, account }) {
      securityLogger.info({
        event: 'LOGIN_SUCCESS',
        userId: user.id,
        email: user.email,
        provider: account?.provider,
      });
    },
    async signOut({ token }) {
      securityLogger.info({
        event: 'LOGOUT',
        userId: token?.id,
        email: token?.email,
      });
    },
  },
  callbacks: {
    async signIn({ user, account, credentials }) {
      // ログイン失敗はauthorize内で記録
      return true;
    },
  },
});

// Server Actionでのログ記録
export async function deleteUser(userId: string) {
  const session = await requireAdmin();

  try {
    await prisma.user.delete({
      where: { id: userId },
    });

    securityLogger.warn({
      event: 'USER_DELETED',
      adminId: session.user.id,
      adminEmail: session.user.email,
      targetUserId: userId,
    });

    return { success: true };
  } catch (error) {
    securityLogger.error({
      event: 'DELETE_ERROR',
      adminId: session.user.id,
      targetUserId: userId,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    return { success: false, error: '削除に失敗しました' };
  }
}
```

## 7. レート制限

### 7.1 API Rate Limiting 実装

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Upstash Redis使用
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// API用レート制限(10リクエスト/10秒)
export const apiRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
  analytics: true,
  prefix: '@upstash/ratelimit:api',
});

// ログイン用レート制限(5試行/15分)
export const loginRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, '15 m'),
  analytics: true,
  prefix: '@upstash/ratelimit:login',
});

// 使用例(API Route)
export async function GET(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1';
  const { success, limit, reset, remaining } = await apiRateLimit.limit(ip);

  if (!success) {
    return NextResponse.json(
      { error: 'Too many requests' },
      {
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': reset.toString(),
        },
      }
    );
  }

  // 通常処理
}
```

## 8. セキュリティテスト項目

### 8.1 認証・認可テスト

- [ ] ログイン機能の正常系動作確認
- [ ] 不正な認証情報でのログイン拒否確認
- [ ] セッションタイムアウト動作確認(30分)
- [ ] ログアウト後のセッション無効化確認
- [ ] 権限のないURLへのアクセス拒否確認(Middleware)
- [ ] アカウントロック機能の動作確認(5回失敗)
- [ ] JWT改ざん検知確認

### 8.2 入力検証テスト

- [ ] 必須項目の未入力チェック(Zodバリデーション)
- [ ] 文字数制限の検証
- [ ] 形式検証(メール、電話番号等)
- [ ] SQLインジェクション耐性確認(Prisma)
- [ ] XSS攻撃耐性確認(React自動エスケープ)
- [ ] Server-side / Client-side両方でのバリデーション

### 8.3 CSRF対策テスト

- [ ] Server Actionsの自動CSRF保護確認
- [ ] SameSite Cookie属性確認
- [ ] Originヘッダー検証(API Routes)
- [ ] トークンなしリクエストの拒否確認

### 8.4 セキュリティヘッダーテスト

- [ ] X-Frame-Options 設定確認
- [ ] Content-Security-Policy 設定確認
- [ ] Strict-Transport-Security 設定確認
- [ ] X-Content-Type-Options 設定確認

## 9. 脆弱性診断・更新管理

### 9.1 定期診断項目

| 診断項目 | 頻度 | 担当 | ツール |
|---------|------|------|--------|
| 依存ライブラリ脆弱性スキャン | 毎週 | 開発チーム | npm audit, Snyk |
| Next.js バージョン更新確認 | 毎月 | 開発チーム | npm outdated |
| ペネトレーションテスト | 半年ごと | セキュリティチーム | OWASP ZAP |
| コードレビュー | 各リリース前 | 開発チーム | GitHub PR |
| 設定レビュー | 四半期ごと | インフラチーム | 手動チェック |

### 9.2 脆弱性対応フロー

```
脆弱性検出(npm audit, Snyk)
  ↓
影響度評価(Critical/High/Medium/Low)
  ↓
Critical/High: 即時対応(24時間以内)
Medium: 計画的対応(1週間以内)
Low: 次回リリースで対応
  ↓
パッチ適用・修正(npm update, コード修正)
  ↓
テスト・検証(Jest, Playwright)
  ↓
デプロイ(Vercel/本番環境)
  ↓
事後確認(npm audit clean)
```

### 9.3 依存関係管理

```bash
# 脆弱性スキャン
npm audit

# 自動修正可能な脆弱性を修正
npm audit fix

# 強制的に修正(破壊的変更の可能性あり)
npm audit fix --force

# Snykでの詳細スキャン
npx snyk test

# 依存関係の更新確認
npm outdated

# Next.js最新版への更新
npm install next@latest react@latest react-dom@latest
```

## 10. インシデント対応

### 10.1 セキュリティインシデント分類

| レベル | 定義 | 対応時間 | エスカレーション |
|--------|------|----------|------------------|
| Critical | システム全体に影響、データ漏洩 | 即時 | 経営層 |
| High | 重要機能停止、不正アクセス | 1時間以内 | 部門長 |
| Medium | 一部機能停止、脆弱性検出 | 4時間以内 | チームリーダー |
| Low | 軽微な問題、潜在的リスク | 1営業日以内 | 担当者 |

### 10.2 インシデント対応手順

1. **検知**: ログ監視(Vercel Analytics)、アラート、報告
2. **初動対応**: 影響範囲の特定、一時的な遮断(環境変数無効化等)
3. **調査**: 原因究明、ログ分析(Pino/Winston)
4. **復旧**: 修正、パッチ適用、サービス再開
5. **事後対応**: 報告書作成、再発防止策の策定

### 10.3 緊急時の対応例

```typescript
// 緊急時: 特定機能の無効化
// .env.local
FEATURE_USER_REGISTRATION=false
FEATURE_API_ACCESS=false

// middleware.ts
export async function middleware(request: NextRequest) {
  // 緊急時の機能無効化
  if (process.env.FEATURE_USER_REGISTRATION === 'false') {
    if (request.nextUrl.pathname.startsWith('/users/register')) {
      return NextResponse.redirect(new URL('/maintenance', request.url));
    }
  }

  // 通常処理
}
```

## 11. 環境変数管理

### 11.1 環境変数命名規則

| 接頭辞 | 用途 | 公開範囲 | 例 |
|--------|------|---------|-----|
| `NEXT_PUBLIC_` | クライアント公開 | ブラウザに露出 | `NEXT_PUBLIC_API_URL` |
| なし | サーバー専用 | サーバーのみ | `DATABASE_URL`, `AUTH_SECRET` |

### 11.2 環境変数セキュリティ

```bash
# .env.local (Gitにコミットしない)
# データベース
DATABASE_URL="postgresql://user:password@localhost:5432/mydb"

# NextAuth.js
AUTH_SECRET="ランダムな長い文字列(openssl rand -base64 32)"
NEXTAUTH_URL="http://localhost:3000"

# Redis(Rate Limiting)
UPSTASH_REDIS_REST_URL="https://..."
UPSTASH_REDIS_REST_TOKEN="..."

# 公開環境変数
NEXT_PUBLIC_APP_URL="http://localhost:3000"
```

### 11.3 本番環境での環境変数管理

- Vercel: Environment Variables機能で管理
- 環境別に設定(Development, Preview, Production)
- シークレットは暗号化して保存
- 定期的にローテーション(AUTH_SECRET等)

---

**文書管理情報**
- 作成日: 2025-11-27
- 最終更新日: 2025-11-27
- 版数: 2.0
- フレームワーク: Next.js 15 (App Router)
- 認証: NextAuth.js v5 (Auth.js)
- ORM: Prisma
- バリデーション: Zod
- 承認者: [承認者名]
- 次回レビュー予定: 2026-02-27
