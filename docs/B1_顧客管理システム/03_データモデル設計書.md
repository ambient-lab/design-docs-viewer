# データモデル設計書

## 文書管理情報

| 項目 | 内容 |
|------|------|
| システム名 | 顧客管理システム |
| サブシステムID | B1 |
| 文書名 | データモデル設計書 |
| 作成日 | 2025-11-27 |
| バージョン | 1.0 |
| フレームワーク | Next.js 15 + Prisma ORM |

## 目次

1. [概要](#概要)
2. [Prismaスキーマ定義](#prismaスキーマ定義)
3. [テーブル定義](#テーブル定義)
4. [ER図](#er図)
5. [インデックス定義](#インデックス定義)
6. [TypeScript型定義](#typescript型定義)
7. [マイグレーション](#マイグレーション)
8. [シードデータ](#シードデータ)
9. [バリデーション定義](#バリデーション定義)
10. [パフォーマンス最適化](#パフォーマンス最適化)

---

## 概要

### 目的
本文書は、顧客管理システム(B1)のNext.js + Prisma ORMを使用したデータベース設計を記載する。

### 対象範囲
- Prismaスキーマ定義
- テーブル定義詳細
- TypeScript型定義
- マイグレーション戦略
- シードデータ設計
- バリデーション定義
- ER図

### データベース設計方針
- **DBMS**: PostgreSQL 14以上
- **ORM**: Prisma 5.x
- **文字コード**: UTF-8
- **命名規則**:
  - Prisma Model: PascalCase
  - データベーステーブル: snake_case
  - TypeScript型: PascalCase
- **監査情報**: 全テーブルに作成日時・更新日時を自動管理
- **楽観的排他制御**: 全テーブルにバージョン番号を保持
- **論理削除**: ステータス更新で対応(物理削除は行わない)
- **ID生成**: CUID (Collision-resistant Unique Identifier)

---

## Prismaスキーマ定義

### schema.prisma

```prisma
// Prisma スキーマファイル
// データベース接続とモデル定義

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// 顧客モデル
// ========================================

/// 顧客の基本情報を管理するモデル
model Customer {
  /// 顧客を一意に識別するID (CUID)
  id              String   @id @default(cuid()) @map("customer_id")

  /// 顧客の氏名
  customerName    String   @map("customer_name") @db.VarChar(100)

  /// 顧客の氏名(カタカナ)
  customerNameKana String  @map("customer_name_kana") @db.VarChar(100)

  /// 顧客の住所
  address         String   @db.VarChar(500)

  /// 顧客の電話番号(ハイフン含む)
  phoneNumber     String   @unique @map("phone_number") @db.VarChar(15)

  /// 顧客のメールアドレス
  email           String   @unique @db.VarChar(256)

  /// 顧客の生年月日
  birthDate       DateTime? @map("birth_date") @db.Date

  /// 顧客の性別 (male/female/other)
  gender          Gender?

  /// その他のメモや備考情報
  notes           String?  @db.VarChar(1000)

  /// 顧客のステータス (ACTIVE/INACTIVE/DELETED)
  status          CustomerStatus @default(ACTIVE)

  /// レコード作成日時
  createdAt       DateTime @default(now()) @map("created_at")

  /// レコード更新日時
  updatedAt       DateTime @updatedAt @map("updated_at")

  /// 楽観的排他制御用バージョン番号
  versionNo       Int      @default(0) @map("version_no")

  /// 顧客履歴とのリレーション
  histories       CustomerHistory[]

  @@index([customerName])
  @@index([customerNameKana])
  @@index([status])
  @@index([createdAt])
  @@index([status, createdAt])
  @@map("customers")
}

// ========================================
// 顧客履歴モデル
// ========================================

/// 顧客情報の変更履歴を管理する監査用モデル
model CustomerHistory {
  /// 履歴レコードを一意に識別するID (CUID)
  id                  String   @id @default(cuid()) @map("history_id")

  /// 対象顧客のID
  customerId          String   @map("customer_id")

  /// 操作の種類 (INSERT/UPDATE/DELETE)
  operationType       OperationType @map("operation_type")

  /// 変更後の顧客名
  customerName        String?  @map("customer_name") @db.VarChar(100)

  /// 変更後の顧客名カナ
  customerNameKana    String?  @map("customer_name_kana") @db.VarChar(100)

  /// 変更後の住所
  address             String?  @db.VarChar(500)

  /// 変更後の電話番号
  phoneNumber         String?  @map("phone_number") @db.VarChar(15)

  /// 変更後のメールアドレス
  email               String?  @db.VarChar(256)

  /// 変更後の生年月日
  birthDate           DateTime? @map("birth_date") @db.Date

  /// 変更後の性別
  gender              Gender?

  /// 変更後の備考
  notes               String?  @db.VarChar(1000)

  /// 変更後のステータス
  status              CustomerStatus?

  /// 変更時のバージョン番号
  versionNo           Int?     @map("version_no")

  /// 操作を実行したユーザー名
  operationUser       String?  @map("operation_user") @db.VarChar(100)

  /// 操作実行日時
  operationTimestamp  DateTime @default(now()) @map("operation_timestamp")

  /// 顧客とのリレーション
  customer            Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([operationTimestamp])
  @@index([customerId, operationTimestamp])
  @@map("customer_history")
}

// ========================================
// Enum定義
// ========================================

/// 顧客ステータス
enum CustomerStatus {
  ACTIVE    // 有効
  INACTIVE  // 無効
  DELETED   // 削除済
}

/// 性別
enum Gender {
  male      // 男性
  female    // 女性
  other     // その他
}

/// 操作種別
enum OperationType {
  INSERT    // 登録
  UPDATE    // 更新
  DELETE    // 削除
}
```

---

## テーブル定義

### 1. customers (顧客)

#### テーブル概要

| 項目 | 内容 |
|------|------|
| 物理名 | customers |
| 論理名 | 顧客 |
| Prisma Model | Customer |
| 説明 | 顧客の基本情報を管理するテーブル |
| 主キー | customer_id |
| ユニーク制約 | email, phone_number |

#### カラム定義

| No. | カラム物理名 | Prismaフィールド | カラム論理名 | データ型 | Prisma型 | NULL | デフォルト値 | 説明 |
|-----|------------|-----------------|------------|---------|---------|------|------------|------|
| 1 | customer_id | id | 顧客ID | VARCHAR(25) | String | NOT NULL | cuid() | 顧客を一意に識別するID |
| 2 | customer_name | customerName | 顧客名 | VARCHAR(100) | String | NOT NULL | - | 顧客の氏名 |
| 3 | customer_name_kana | customerNameKana | 顧客名カナ | VARCHAR(100) | String | NOT NULL | - | 顧客の氏名(カタカナ) |
| 4 | address | address | 住所 | VARCHAR(500) | String | NOT NULL | - | 顧客の住所 |
| 5 | phone_number | phoneNumber | 電話番号 | VARCHAR(15) | String | NOT NULL | - | 顧客の電話番号(ハイフン含む) |
| 6 | email | email | メールアドレス | VARCHAR(256) | String | NOT NULL | - | 顧客のメールアドレス |
| 7 | birth_date | birthDate | 生年月日 | DATE | DateTime? | NULL | - | 顧客の生年月日 |
| 8 | gender | gender | 性別 | ENUM | Gender? | NULL | - | 顧客の性別(male/female/other) |
| 9 | notes | notes | 備考 | VARCHAR(1000) | String? | NULL | - | その他のメモや備考情報 |
| 10 | status | status | ステータス | ENUM | CustomerStatus | NOT NULL | ACTIVE | 顧客のステータス |
| 11 | created_at | createdAt | 作成日時 | TIMESTAMP | DateTime | NOT NULL | now() | レコード作成日時 |
| 12 | updated_at | updatedAt | 更新日時 | TIMESTAMP | DateTime | NOT NULL | updatedAt | レコード更新日時 |
| 13 | version_no | versionNo | バージョン番号 | INTEGER | Int | NOT NULL | 0 | 楽観的排他制御用 |

#### 制約定義

| 制約種別 | 制約名 | 対象カラム | 説明 |
|---------|--------|----------|------|
| PRIMARY KEY | customers_pkey | customer_id | 主キー制約 |
| UNIQUE | customers_email_key | email | メールアドレスの一意制約 |
| UNIQUE | customers_phone_number_key | phone_number | 電話番号の一意制約 |

#### インデックス定義

| インデックス名 | 対象カラム | 種別 | 説明 |
|-------------|----------|------|------|
| customers_customer_name_idx | customer_name | BTREE | 顧客名検索用 |
| customers_customer_name_kana_idx | customer_name_kana | BTREE | 顧客名カナ検索用 |
| customers_status_idx | status | BTREE | ステータス検索用 |
| customers_created_at_idx | created_at | BTREE | 作成日時検索用 |
| customers_status_created_at_idx | status, created_at | BTREE | 複合検索用 |

---

### 2. customer_history (顧客履歴)

#### テーブル概要

| 項目 | 内容 |
|------|------|
| 物理名 | customer_history |
| 論理名 | 顧客履歴 |
| Prisma Model | CustomerHistory |
| 説明 | 顧客情報の変更履歴を管理する監査用テーブル |
| 主キー | history_id |
| 外部キー | customer_id → customers.customer_id |

#### カラム定義

| No. | カラム物理名 | Prismaフィールド | カラム論理名 | データ型 | Prisma型 | NULL | デフォルト値 | 説明 |
|-----|------------|-----------------|------------|---------|---------|------|------------|------|
| 1 | history_id | id | 履歴ID | VARCHAR(25) | String | NOT NULL | cuid() | 履歴レコードを一意に識別するID |
| 2 | customer_id | customerId | 顧客ID | VARCHAR(25) | String | NOT NULL | - | 対象顧客のID |
| 3 | operation_type | operationType | 操作種別 | ENUM | OperationType | NOT NULL | - | 操作の種類 |
| 4 | customer_name | customerName | 顧客名 | VARCHAR(100) | String? | NULL | - | 変更後の顧客名 |
| 5 | customer_name_kana | customerNameKana | 顧客名カナ | VARCHAR(100) | String? | NULL | - | 変更後の顧客名カナ |
| 6 | address | address | 住所 | VARCHAR(500) | String? | NULL | - | 変更後の住所 |
| 7 | phone_number | phoneNumber | 電話番号 | VARCHAR(15) | String? | NULL | - | 変更後の電話番号 |
| 8 | email | email | メールアドレス | VARCHAR(256) | String? | NULL | - | 変更後のメールアドレス |
| 9 | birth_date | birthDate | 生年月日 | DATE | DateTime? | NULL | - | 変更後の生年月日 |
| 10 | gender | gender | 性別 | ENUM | Gender? | NULL | - | 変更後の性別 |
| 11 | notes | notes | 備考 | VARCHAR(1000) | String? | NULL | - | 変更後の備考 |
| 12 | status | status | ステータス | ENUM | CustomerStatus? | NULL | - | 変更後のステータス |
| 13 | version_no | versionNo | バージョン番号 | INTEGER | Int? | NULL | - | 変更時のバージョン番号 |
| 14 | operation_user | operationUser | 操作ユーザー | VARCHAR(100) | String? | NULL | - | 操作を実行したユーザー名 |
| 15 | operation_timestamp | operationTimestamp | 操作日時 | TIMESTAMP | DateTime | NOT NULL | now() | 操作実行日時 |

#### 制約定義

| 制約種別 | 制約名 | 対象カラム | 説明 |
|---------|--------|----------|------|
| PRIMARY KEY | customer_history_pkey | history_id | 主キー制約 |
| FOREIGN KEY | customer_history_customer_id_fkey | customer_id | 外部キー制約(customers.customer_id) |

#### インデックス定義

| インデックス名 | 対象カラム | 種別 | 説明 |
|-------------|----------|------|------|
| customer_history_customer_id_idx | customer_id | BTREE | 顧客ID検索用 |
| customer_history_operation_timestamp_idx | operation_timestamp | BTREE | 操作日時検索用 |
| customer_history_customer_id_operation_timestamp_idx | customer_id, operation_timestamp | BTREE | 顧客別履歴検索用 |

---

## ER図

### 概念ER図

```mermaid
erDiagram
    CUSTOMER ||--o{ CUSTOMER_HISTORY : "has history"

    CUSTOMER {
        string customer_id PK "顧客ID (CUID)"
        string customer_name "顧客名"
        string customer_name_kana "顧客名カナ"
        string address "住所"
        string phone_number UK "電話番号"
        string email UK "メールアドレス"
        date birth_date "生年月日"
        enum gender "性別"
        string notes "備考"
        enum status "ステータス"
        datetime created_at "作成日時"
        datetime updated_at "更新日時"
        int version_no "バージョン番号"
    }

    CUSTOMER_HISTORY {
        string history_id PK "履歴ID (CUID)"
        string customer_id FK "顧客ID"
        enum operation_type "操作種別"
        string customer_name "顧客名"
        string customer_name_kana "顧客名カナ"
        string address "住所"
        string phone_number "電話番号"
        string email "メールアドレス"
        date birth_date "生年月日"
        enum gender "性別"
        string notes "備考"
        enum status "ステータス"
        int version_no "バージョン番号"
        string operation_user "操作ユーザー"
        datetime operation_timestamp "操作日時"
    }
```

### リレーション説明

| 親モデル | 子モデル | リレーション | カーディナリティ | 説明 |
|---------|---------|------------|---------------|------|
| Customer | CustomerHistory | 1:N | 1つの顧客に対して複数の履歴 | 顧客情報が変更されるたびに履歴レコードが作成される |

### リレーション設定詳細

```prisma
// Customer → CustomerHistory (1:N)
model Customer {
  // ...
  histories CustomerHistory[] // 顧客の履歴一覧
}

model CustomerHistory {
  // ...
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  // カスケード削除: 顧客が削除されると履歴も削除される
}
```

---

## インデックス定義

### インデックス戦略

Prismaでは、`@@index`属性を使用してインデックスを定義します。

#### customers テーブルのインデックス

```prisma
model Customer {
  // ... fields

  @@index([customerName])           // 顧客名検索用
  @@index([customerNameKana])       // 顧客名カナ検索用
  @@index([status])                 // ステータス検索用
  @@index([createdAt])              // 作成日時検索用
  @@index([status, createdAt])      // 複合検索用(ステータス + 作成日時)

  @@map("customers")
}
```

#### customer_history テーブルのインデックス

```prisma
model CustomerHistory {
  // ... fields

  @@index([customerId])                         // 顧客ID検索用
  @@index([operationTimestamp])                 // 操作日時検索用
  @@index([customerId, operationTimestamp])     // 顧客別履歴検索用複合インデックス

  @@map("customer_history")
}
```

### インデックス使用例

```typescript
// 顧客名による検索 (customerName インデックスを使用)
const customers = await prisma.customer.findMany({
  where: {
    customerName: {
      contains: '山田',
    },
  },
});

// ステータスと作成日時による検索 (複合インデックスを使用)
const activeCustomers = await prisma.customer.findMany({
  where: {
    status: 'ACTIVE',
    createdAt: {
      gte: new Date('2025-01-01'),
    },
  },
  orderBy: {
    createdAt: 'desc',
  },
});

// 顧客の履歴取得 (複合インデックスを使用)
const history = await prisma.customerHistory.findMany({
  where: {
    customerId: 'clx1234567890',
  },
  orderBy: {
    operationTimestamp: 'desc',
  },
});
```

---

## TypeScript型定義

### Prisma自動生成型

Prismaは`@prisma/client`から自動的に型定義を生成します。

```typescript
import { Prisma, Customer, CustomerHistory, CustomerStatus, Gender, OperationType } from '@prisma/client';

// ========================================
// 基本型 (Prisma自動生成)
// ========================================

// Customer型
type Customer = {
  id: string;
  customerName: string;
  customerNameKana: string;
  address: string;
  phoneNumber: string;
  email: string;
  birthDate: Date | null;
  gender: Gender | null;
  notes: string | null;
  status: CustomerStatus;
  createdAt: Date;
  updatedAt: Date;
  versionNo: number;
};

// CustomerHistory型
type CustomerHistory = {
  id: string;
  customerId: string;
  operationType: OperationType;
  customerName: string | null;
  customerNameKana: string | null;
  address: string | null;
  phoneNumber: string | null;
  email: string | null;
  birthDate: Date | null;
  gender: Gender | null;
  notes: string | null;
  status: CustomerStatus | null;
  versionNo: number | null;
  operationUser: string | null;
  operationTimestamp: Date;
};

// Enum型
enum CustomerStatus {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  DELETED = 'DELETED',
}

enum Gender {
  male = 'male',
  female = 'female',
  other = 'other',
}

enum OperationType {
  INSERT = 'INSERT',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
}
```

### アプリケーション用カスタム型

```typescript
// ========================================
// 入力型 (Create/Update用)
// ========================================

// 顧客作成入力型
export type CustomerCreateInput = Prisma.CustomerCreateInput;

// または、カスタム定義
export type CreateCustomerInput = {
  customerName: string;
  customerNameKana: string;
  address: string;
  phoneNumber: string;
  email: string;
  birthDate?: Date;
  gender?: Gender;
  notes?: string;
};

// 顧客更新入力型
export type UpdateCustomerInput = Partial<CreateCustomerInput> & {
  versionNo: number; // 楽観的排他制御用
};

// ========================================
// 検索条件型
// ========================================

export type CustomerSearchInput = {
  customerName?: string;
  customerNameKana?: string;
  email?: string;
  phoneNumber?: string;
  status?: CustomerStatus;
  createdAtFrom?: Date;
  createdAtTo?: Date;
};

// ========================================
// リレーション含む型
// ========================================

// 履歴を含む顧客型
export type CustomerWithHistories = Prisma.CustomerGetPayload<{
  include: { histories: true };
}>;

// 顧客情報を含む履歴型
export type CustomerHistoryWithCustomer = Prisma.CustomerHistoryGetPayload<{
  include: { customer: true };
}>;

// ========================================
// ページネーション型
// ========================================

export type PaginationInput = {
  page: number;
  limit: number;
};

export type PaginatedResult<T> = {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
};

// ========================================
// API レスポンス型
// ========================================

export type CustomerResponse = {
  id: string;
  customerName: string;
  customerNameKana: string;
  address: string;
  phoneNumber: string;
  email: string;
  birthDate: string | null; // ISO8601形式の文字列
  gender: Gender | null;
  notes: string | null;
  status: CustomerStatus;
  createdAt: string; // ISO8601形式の文字列
  updatedAt: string; // ISO8601形式の文字列
  versionNo: number;
};

export type CustomerHistoryResponse = {
  id: string;
  customerId: string;
  operationType: OperationType;
  customerName: string | null;
  customerNameKana: string | null;
  address: string | null;
  phoneNumber: string | null;
  email: string | null;
  birthDate: string | null;
  gender: Gender | null;
  notes: string | null;
  status: CustomerStatus | null;
  versionNo: number | null;
  operationUser: string | null;
  operationTimestamp: string; // ISO8601形式の文字列
};
```

### 型ガード関数

```typescript
// ========================================
// 型ガード
// ========================================

export function isCustomerStatus(value: unknown): value is CustomerStatus {
  return typeof value === 'string' && ['ACTIVE', 'INACTIVE', 'DELETED'].includes(value);
}

export function isGender(value: unknown): value is Gender {
  return typeof value === 'string' && ['male', 'female', 'other'].includes(value);
}

export function isOperationType(value: unknown): value is OperationType {
  return typeof value === 'string' && ['INSERT', 'UPDATE', 'DELETE'].includes(value);
}
```

---

## マイグレーション

### 初期マイグレーション作成

```bash
# Prismaスキーマから初回マイグレーション生成
npx prisma migrate dev --name init

# マイグレーション履歴確認
npx prisma migrate status

# 本番環境へのマイグレーション適用
npx prisma migrate deploy
```

### マイグレーションファイル構成

```
prisma/
├── schema.prisma
└── migrations/
    ├── 20251127000001_init/
    │   └── migration.sql
    ├── 20251127000002_add_customer_indexes/
    │   └── migration.sql
    └── migration_lock.toml
```

### 初回マイグレーションSQL (自動生成)

`prisma/migrations/20251127000001_init/migration.sql`:

```sql
-- CreateEnum
CREATE TYPE "CustomerStatus" AS ENUM ('ACTIVE', 'INACTIVE', 'DELETED');

-- CreateEnum
CREATE TYPE "Gender" AS ENUM ('male', 'female', 'other');

-- CreateEnum
CREATE TYPE "OperationType" AS ENUM ('INSERT', 'UPDATE', 'DELETE');

-- CreateTable
CREATE TABLE "customers" (
    "customer_id" TEXT NOT NULL,
    "customer_name" VARCHAR(100) NOT NULL,
    "customer_name_kana" VARCHAR(100) NOT NULL,
    "address" VARCHAR(500) NOT NULL,
    "phone_number" VARCHAR(15) NOT NULL,
    "email" VARCHAR(256) NOT NULL,
    "birth_date" DATE,
    "gender" "Gender",
    "notes" VARCHAR(1000),
    "status" "CustomerStatus" NOT NULL DEFAULT 'ACTIVE',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "version_no" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "customers_pkey" PRIMARY KEY ("customer_id")
);

-- CreateTable
CREATE TABLE "customer_history" (
    "history_id" TEXT NOT NULL,
    "customer_id" TEXT NOT NULL,
    "operation_type" "OperationType" NOT NULL,
    "customer_name" VARCHAR(100),
    "customer_name_kana" VARCHAR(100),
    "address" VARCHAR(500),
    "phone_number" VARCHAR(15),
    "email" VARCHAR(256),
    "birth_date" DATE,
    "gender" "Gender",
    "notes" VARCHAR(1000),
    "status" "CustomerStatus",
    "version_no" INTEGER,
    "operation_user" VARCHAR(100),
    "operation_timestamp" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "customer_history_pkey" PRIMARY KEY ("history_id")
);

-- CreateIndex
CREATE UNIQUE INDEX "customers_phone_number_key" ON "customers"("phone_number");

-- CreateIndex
CREATE UNIQUE INDEX "customers_email_key" ON "customers"("email");

-- CreateIndex
CREATE INDEX "customers_customer_name_idx" ON "customers"("customer_name");

-- CreateIndex
CREATE INDEX "customers_customer_name_kana_idx" ON "customers"("customer_name_kana");

-- CreateIndex
CREATE INDEX "customers_status_idx" ON "customers"("status");

-- CreateIndex
CREATE INDEX "customers_created_at_idx" ON "customers"("created_at");

-- CreateIndex
CREATE INDEX "customers_status_created_at_idx" ON "customers"("status", "created_at");

-- CreateIndex
CREATE INDEX "customer_history_customer_id_idx" ON "customer_history"("customer_id");

-- CreateIndex
CREATE INDEX "customer_history_operation_timestamp_idx" ON "customer_history"("operation_timestamp");

-- CreateIndex
CREATE INDEX "customer_history_customer_id_operation_timestamp_idx" ON "customer_history"("customer_id", "operation_timestamp");

-- AddForeignKey
ALTER TABLE "customer_history" ADD CONSTRAINT "customer_history_customer_id_fkey" FOREIGN KEY ("customer_id") REFERENCES "customers"("customer_id") ON DELETE CASCADE ON UPDATE CASCADE;
```

### マイグレーション運用

#### 開発環境

```bash
# スキーマ変更後、マイグレーション作成
npx prisma migrate dev --name <migration_name>

# マイグレーションをリセット(開発環境のみ)
npx prisma migrate reset
```

#### 本番環境

```bash
# マイグレーション適用(ダウンタイムなし)
npx prisma migrate deploy

# マイグレーション状態確認
npx prisma migrate status
```

---

## シードデータ

### シードスクリプト設定

`package.json`:

```json
{
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}
```

### シードデータ定義

`prisma/seed.ts`:

```typescript
import { PrismaClient, CustomerStatus, Gender } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('Start seeding...');

  // ========================================
  // 顧客データ
  // ========================================

  const customers = [
    {
      customerName: '山田 太郎',
      customerNameKana: 'ヤマダ タロウ',
      address: '東京都渋谷区渋谷1-1-1',
      phoneNumber: '03-1234-5678',
      email: 'yamada.taro@example.com',
      birthDate: new Date('1985-04-15'),
      gender: Gender.male,
      notes: 'VIP顧客',
      status: CustomerStatus.ACTIVE,
    },
    {
      customerName: '佐藤 花子',
      customerNameKana: 'サトウ ハナコ',
      address: '神奈川県横浜市西区みなとみらい2-2-2',
      phoneNumber: '045-2345-6789',
      email: 'sato.hanako@example.com',
      birthDate: new Date('1990-08-22'),
      gender: Gender.female,
      notes: '定期購入顧客',
      status: CustomerStatus.ACTIVE,
    },
    {
      customerName: '鈴木 一郎',
      customerNameKana: 'スズキ イチロウ',
      address: '大阪府大阪市北区梅田3-3-3',
      phoneNumber: '06-3456-7890',
      email: 'suzuki.ichiro@example.com',
      birthDate: new Date('1978-12-05'),
      gender: Gender.male,
      notes: null,
      status: CustomerStatus.ACTIVE,
    },
    {
      customerName: '田中 美咲',
      customerNameKana: 'タナカ ミサキ',
      address: '福岡県福岡市博多区博多駅前4-4-4',
      phoneNumber: '092-4567-8901',
      email: 'tanaka.misaki@example.com',
      birthDate: new Date('1995-03-18'),
      gender: Gender.female,
      notes: 'メールマガジン購読中',
      status: CustomerStatus.ACTIVE,
    },
    {
      customerName: '高橋 健太',
      customerNameKana: 'タカハシ ケンタ',
      address: '北海道札幌市中央区大通西5-5-5',
      phoneNumber: '011-5678-9012',
      email: 'takahashi.kenta@example.com',
      birthDate: new Date('1988-11-30'),
      gender: Gender.male,
      notes: '休眠顧客',
      status: CustomerStatus.INACTIVE,
    },
  ];

  for (const customer of customers) {
    await prisma.customer.create({
      data: customer,
    });
    console.log(`Created customer: ${customer.customerName}`);
  }

  console.log('Seeding finished.');
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
```

### シード実行

```bash
# シードデータ投入
npx prisma db seed

# データベースリセット + マイグレーション + シード
npx prisma migrate reset
```

---

## バリデーション定義

### Zodスキーマによるバリデーション

`lib/validations/customer.ts`:

```typescript
import { z } from 'zod';
import { CustomerStatus, Gender } from '@prisma/client';

// ========================================
// 顧客バリデーション
// ========================================

export const customerNameSchema = z
  .string()
  .min(1, '顧客名は必須です')
  .max(100, '顧客名は100文字以内で入力してください');

export const customerNameKanaSchema = z
  .string()
  .min(1, '顧客名カナは必須です')
  .max(100, '顧客名カナは100文字以内で入力してください')
  .regex(/^[ァ-ヶー\s]+$/, '顧客名カナは全角カタカナで入力してください');

export const addressSchema = z
  .string()
  .min(1, '住所は必須です')
  .max(500, '住所は500文字以内で入力してください');

export const phoneNumberSchema = z
  .string()
  .min(1, '電話番号は必須です')
  .max(15, '電話番号は15文字以内で入力してください')
  .regex(/^[0-9-]+$/, '電話番号は数字とハイフンのみで入力してください');

export const emailSchema = z
  .string()
  .min(1, 'メールアドレスは必須です')
  .email('有効なメールアドレスを入力してください')
  .max(256, 'メールアドレスは256文字以内で入力してください');

export const birthDateSchema = z
  .date()
  .min(new Date('1900-01-01'), '生年月日は1900年1月1日以降を入力してください')
  .max(new Date(), '生年月日は現在日以前を入力してください')
  .optional();

export const genderSchema = z.nativeEnum(Gender).optional();

export const notesSchema = z
  .string()
  .max(1000, '備考は1000文字以内で入力してください')
  .optional();

export const statusSchema = z.nativeEnum(CustomerStatus);

export const versionNoSchema = z.number().int().min(0, 'バージョン番号は0以上の整数です');

// ========================================
// 顧客作成スキーマ
// ========================================

export const createCustomerSchema = z.object({
  customerName: customerNameSchema,
  customerNameKana: customerNameKanaSchema,
  address: addressSchema,
  phoneNumber: phoneNumberSchema,
  email: emailSchema,
  birthDate: birthDateSchema,
  gender: genderSchema,
  notes: notesSchema,
});

export type CreateCustomerSchema = z.infer<typeof createCustomerSchema>;

// ========================================
// 顧客更新スキーマ
// ========================================

export const updateCustomerSchema = z.object({
  customerName: customerNameSchema.optional(),
  customerNameKana: customerNameKanaSchema.optional(),
  address: addressSchema.optional(),
  phoneNumber: phoneNumberSchema.optional(),
  email: emailSchema.optional(),
  birthDate: birthDateSchema,
  gender: genderSchema,
  notes: notesSchema,
  status: statusSchema.optional(),
  versionNo: versionNoSchema, // 楽観的排他制御用(必須)
});

export type UpdateCustomerSchema = z.infer<typeof updateCustomerSchema>;

// ========================================
// 顧客検索スキーマ
// ========================================

export const searchCustomerSchema = z.object({
  customerName: z.string().optional(),
  customerNameKana: z.string().optional(),
  email: z.string().optional(),
  phoneNumber: z.string().optional(),
  status: statusSchema.optional(),
  createdAtFrom: z.date().optional(),
  createdAtTo: z.date().optional(),
});

export type SearchCustomerSchema = z.infer<typeof searchCustomerSchema>;

// ========================================
// ページネーションスキーマ
// ========================================

export const paginationSchema = z.object({
  page: z.number().int().min(1, 'ページ番号は1以上です').default(1),
  limit: z.number().int().min(1).max(100, '取得件数は100件以内です').default(20),
});

export type PaginationSchema = z.infer<typeof paginationSchema>;
```

### バリデーション使用例

```typescript
import { createCustomerSchema } from '@/lib/validations/customer';

export async function POST(request: Request) {
  try {
    const body = await request.json();

    // バリデーション実行
    const validatedData = createCustomerSchema.parse(body);

    // データベース登録
    const customer = await prisma.customer.create({
      data: validatedData,
    });

    return Response.json(customer);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json(
        { error: 'バリデーションエラー', details: error.errors },
        { status: 400 }
      );
    }
    throw error;
  }
}
```

---

## パフォーマンス最適化

### 1. クエリ最適化

#### N+1問題の回避

```typescript
// ❌ Bad: N+1問題が発生
const customers = await prisma.customer.findMany();
for (const customer of customers) {
  const histories = await prisma.customerHistory.findMany({
    where: { customerId: customer.id },
  });
}

// ✅ Good: includeで一度に取得
const customers = await prisma.customer.findMany({
  include: {
    histories: {
      orderBy: {
        operationTimestamp: 'desc',
      },
      take: 10, // 最新10件のみ
    },
  },
});
```

#### 必要なフィールドのみ取得

```typescript
// ❌ Bad: 全フィールド取得
const customers = await prisma.customer.findMany();

// ✅ Good: selectで必要なフィールドのみ
const customers = await prisma.customer.findMany({
  select: {
    id: true,
    customerName: true,
    email: true,
    status: true,
  },
});
```

### 2. インデックス活用

```typescript
// status + createdAt の複合インデックスを活用
const activeCustomers = await prisma.customer.findMany({
  where: {
    status: 'ACTIVE',
    createdAt: {
      gte: new Date('2025-01-01'),
    },
  },
  orderBy: {
    createdAt: 'desc',
  },
});
```

### 3. ページネーション実装

```typescript
// ========================================
// カーソルベースページネーション(推奨)
// ========================================

export async function getCustomersCursor(
  cursor?: string,
  limit: number = 20
) {
  const customers = await prisma.customer.findMany({
    take: limit + 1, // 次ページの有無判定用に+1
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: {
      createdAt: 'desc',
    },
  });

  const hasNext = customers.length > limit;
  const data = hasNext ? customers.slice(0, -1) : customers;
  const nextCursor = hasNext ? data[data.length - 1].id : null;

  return {
    data,
    nextCursor,
    hasNext,
  };
}

// ========================================
// オフセットベースページネーション
// ========================================

export async function getCustomersOffset(
  page: number = 1,
  limit: number = 20
) {
  const skip = (page - 1) * limit;

  const [data, total] = await prisma.$transaction([
    prisma.customer.findMany({
      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc',
      },
    }),
    prisma.customer.count(),
  ]);

  return {
    data,
    pagination: {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrev: page > 1,
    },
  };
}
```

### 4. バッチ操作

```typescript
// ========================================
// 複数レコードの一括作成
// ========================================

await prisma.customer.createMany({
  data: [
    { customerName: '顧客1', email: 'customer1@example.com', /* ... */ },
    { customerName: '顧客2', email: 'customer2@example.com', /* ... */ },
  ],
  skipDuplicates: true, // 重複をスキップ
});

// ========================================
// トランザクション処理
// ========================================

await prisma.$transaction(async (tx) => {
  // 顧客作成
  const customer = await tx.customer.create({
    data: customerData,
  });

  // 履歴記録
  await tx.customerHistory.create({
    data: {
      customerId: customer.id,
      operationType: 'INSERT',
      ...customerData,
      operationUser: 'system',
    },
  });
});
```

### 5. 楽観的排他制御

```typescript
// ========================================
// バージョン番号による楽観的排他制御
// ========================================

export async function updateCustomerWithOptimisticLock(
  id: string,
  data: UpdateCustomerInput,
  currentVersionNo: number
) {
  try {
    const updated = await prisma.customer.update({
      where: {
        id,
        versionNo: currentVersionNo, // 現在のバージョン番号で検索
      },
      data: {
        ...data,
        versionNo: {
          increment: 1, // バージョン番号をインクリメント
        },
      },
    });

    return { success: true, data: updated };
  } catch (error) {
    // レコードが見つからない = 他のユーザーが更新済み
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2025') {
        return {
          success: false,
          error: '他のユーザーによって更新されています。再読み込みしてください。',
        };
      }
    }
    throw error;
  }
}
```

### 6. キャッシュ戦略

```typescript
import { unstable_cache } from 'next/cache';

// ========================================
// Next.js Cache による顧客データキャッシュ
// ========================================

export const getCachedCustomer = unstable_cache(
  async (id: string) => {
    return await prisma.customer.findUnique({
      where: { id },
    });
  },
  ['customer'], // キャッシュキー
  {
    revalidate: 60, // 60秒でキャッシュを再検証
    tags: ['customer'], // タグベースの無効化
  }
);

// キャッシュ無効化
import { revalidateTag } from 'next/cache';

export async function updateCustomer(id: string, data: UpdateCustomerInput) {
  const updated = await prisma.customer.update({
    where: { id },
    data,
  });

  // キャッシュ無効化
  revalidateTag('customer');

  return updated;
}
```

### 7. 接続プール最適化

`lib/prisma.ts`:

```typescript
import { PrismaClient } from '@prisma/client';

// ========================================
// Prismaクライアント シングルトン
// ========================================

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    // 接続プール設定
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// アプリケーション終了時の接続クローズ
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

`.env`:

```bash
# 接続プール設定を含むDATABASE_URL
DATABASE_URL="postgresql://user:password@localhost:5432/customer_db?schema=public&connection_limit=10&pool_timeout=20"
```

---

## 改訂履歴

| バージョン | 改訂日 | 改訂内容 | 改訂者 |
|----------|--------|---------|--------|
| 1.0 | 2025-11-27 | Next.js + Prisma版として新規作成 | - |
