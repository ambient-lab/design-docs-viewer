# メッセージ設計書

## 文書管理情報

| 項目 | 内容 |
|------|------|
| システム名 | 顧客管理システム |
| サブシステムID | B1 |
| 文書名 | メッセージ設計書 (Next.js) |
| 作成日 | 2025-11-27 |
| バージョン | 2.0 |

## 目次

1. [概要](#概要)
2. [エラーコード定義](#エラーコード定義)
3. [型定義](#型定義)
4. [エラークラス実装](#エラークラス実装)
5. [バリデーションエラー](#バリデーションエラー)
6. [ビジネスエラー](#ビジネスエラー)
7. [エラーハンドリング実装](#エラーハンドリング実装)
8. [メッセージ定義](#メッセージ定義)

---

## 概要

### 目的
本文書は、Next.js App Routerで構築する顧客管理システム(B1)のAPIエラーハンドリング設計を記載する。

### 対象範囲
- Next.js API Routes (App Router) のエラーハンドリング
- Zodバリデーションエラーの変換
- ビジネスロジックエラーの定義
- TypeScript型安全なエラーレスポンス

### 技術スタック
- Next.js 14+ (App Router)
- TypeScript 5+
- Zod (バリデーション)
- Prisma (データベース)

### 設計方針
- エラーコードは`FB1`で始まる7桁の数値コード
- HTTPステータスコードと紐付けた型安全なエラー処理
- Zodバリデーションエラーの自動変換
- フィールド単位でのエラー情報提供
- 国際化対応を考慮したメッセージ構造

---

## エラーコード定義

### エラーコード体系

```
FB1999901 ~ FB1999999: システム共通エラー
FB1001001 ~ FB1001999: 顧客検索機能固有エラー
FB1002001 ~ FB1002999: 顧客詳細機能固有エラー
FB1003001 ~ FB1003999: 顧客登録機能固有エラー
FB1004001 ~ FB1004999: 顧客更新機能固有エラー
FB1005001 ~ FB1005999: 顧客削除機能固有エラー
```

### 共通エラーコード一覧

| エラーコード | HTTPステータス | エラー名 | 説明 |
|------------|--------------|---------|------|
| FB1999901 | 404 | Not Found | 顧客が見つかりません |
| FB1999902 | 400 | Bad Request | バリデーションエラー |
| FB1999903 | 401 | Unauthorized | 認証エラー |
| FB1999904 | 403 | Forbidden | 権限エラー |
| FB1999905 | 409 | Conflict | 楽観的排他エラー |
| FB1999906 | 409 | Conflict | 一意制約違反エラー |
| FB1999999 | 500 | Internal Server Error | システムエラー |

---

## 型定義

### エラーレスポンス型

```typescript
// lib/api/types.ts

/**
 * APIエラーレスポンス型
 */
export type ApiErrorResponse = {
  /** エラーコード (FB1999901 形式) */
  code: string;
  /** エラーメッセージ */
  message: string;
  /** フィールド単位のエラー詳細 (バリデーションエラー時) */
  details?: Record<string, string[]>;
  /** エラー発生時刻 (ISO 8601形式) */
  timestamp?: string;
};

/**
 * フィールドエラー型 (レガシー形式との互換性用)
 */
export type FieldError = {
  fieldName: string | null;
  message: string;
};

/**
 * レガシーエラーレスポンス型
 */
export type LegacyErrorResponse = {
  faultCode: string;
  messages: FieldError[];
};
```

### エラーコード列挙型

```typescript
// lib/api/error-codes.ts

/**
 * APIエラーコード定義
 */
export const ErrorCode = {
  /** 顧客が見つかりません */
  NOT_FOUND: 'FB1999901',
  /** バリデーションエラー */
  VALIDATION_ERROR: 'FB1999902',
  /** 認証エラー */
  UNAUTHORIZED: 'FB1999903',
  /** 権限エラー */
  FORBIDDEN: 'FB1999904',
  /** 楽観的排他エラー */
  OPTIMISTIC_LOCK: 'FB1999905',
  /** 一意制約違反エラー */
  DUPLICATE: 'FB1999906',
  /** システムエラー */
  INTERNAL_ERROR: 'FB1999999',
} as const;

export type ErrorCodeType = typeof ErrorCode[keyof typeof ErrorCode];

/**
 * エラーコードとHTTPステータスコードのマッピング
 */
export const ErrorStatusMap: Record<ErrorCodeType, number> = {
  [ErrorCode.NOT_FOUND]: 404,
  [ErrorCode.VALIDATION_ERROR]: 400,
  [ErrorCode.UNAUTHORIZED]: 401,
  [ErrorCode.FORBIDDEN]: 403,
  [ErrorCode.OPTIMISTIC_LOCK]: 409,
  [ErrorCode.DUPLICATE]: 409,
  [ErrorCode.INTERNAL_ERROR]: 500,
};
```

---

## エラークラス実装

### 基底エラークラス

```typescript
// lib/api/errors.ts

import { ErrorCode, ErrorCodeType, ErrorStatusMap } from './error-codes';
import type { ApiErrorResponse } from './types';

/**
 * APIエラー基底クラス
 */
export class ApiError extends Error {
  public readonly code: ErrorCodeType;
  public readonly status: number;
  public readonly details?: Record<string, string[]>;
  public readonly timestamp: string;

  constructor(
    code: ErrorCodeType,
    message: string,
    details?: Record<string, string[]>
  ) {
    super(message);
    this.name = 'ApiError';
    this.code = code;
    this.status = ErrorStatusMap[code];
    this.details = details;
    this.timestamp = new Date().toISOString();

    // スタックトレースの調整
    Error.captureStackTrace?.(this, this.constructor);
  }

  /**
   * エラーレスポンスオブジェクトに変換
   */
  toResponse(): ApiErrorResponse {
    return {
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: this.timestamp,
    };
  }

  /**
   * JSONシリアライズ時の処理
   */
  toJSON(): ApiErrorResponse {
    return this.toResponse();
  }
}
```

### 個別エラークラス

```typescript
// lib/api/errors.ts (続き)

/**
 * 顧客が見つからないエラー
 */
export class CustomerNotFoundError extends ApiError {
  constructor(customerId?: string) {
    const message = customerId
      ? `顧客ID ${customerId} が見つかりません`
      : '指定された顧客情報が見つかりません';
    super(ErrorCode.NOT_FOUND, message);
    this.name = 'CustomerNotFoundError';
  }
}

/**
 * バリデーションエラー
 */
export class ValidationError extends ApiError {
  constructor(details: Record<string, string[]>, message = '入力値が正しくありません') {
    super(ErrorCode.VALIDATION_ERROR, message, details);
    this.name = 'ValidationError';
  }
}

/**
 * 認証エラー
 */
export class UnauthorizedError extends ApiError {
  constructor(message = '認証が必要です') {
    super(ErrorCode.UNAUTHORIZED, message);
    this.name = 'UnauthorizedError';
  }
}

/**
 * 権限エラー
 */
export class ForbiddenError extends ApiError {
  constructor(message = 'この操作を実行する権限がありません') {
    super(ErrorCode.FORBIDDEN, message);
    this.name = 'ForbiddenError';
  }
}

/**
 * 楽観的排他制御エラー
 */
export class OptimisticLockError extends ApiError {
  constructor(message = 'データが他のユーザーによって更新されています。最新のデータを取得し直してください') {
    super(ErrorCode.OPTIMISTIC_LOCK, message);
    this.name = 'OptimisticLockError';
  }
}

/**
 * 一意制約違反エラー
 */
export class DuplicateError extends ApiError {
  constructor(field: string, value?: string) {
    const fieldMessages: Record<string, string> = {
      email: 'このメールアドレスは既に登録されています',
      phoneNumber: 'この電話番号は既に登録されています',
    };

    const message = fieldMessages[field] || `${field}が重複しています`;
    const details = { [field]: [message] };

    super(ErrorCode.DUPLICATE, message, details);
    this.name = 'DuplicateError';
  }
}

/**
 * システムエラー
 */
export class InternalServerError extends ApiError {
  constructor(message = 'システムエラーが発生しました。管理者に連絡してください', originalError?: Error) {
    super(ErrorCode.INTERNAL_ERROR, message);
    this.name = 'InternalServerError';

    // 開発環境では元のエラーをログ出力
    if (process.env.NODE_ENV === 'development' && originalError) {
      console.error('Original error:', originalError);
    }
  }
}
```

---

## バリデーションエラー

### Zodスキーマ定義

```typescript
// lib/validations/customer.ts

import { z } from 'zod';

/**
 * カタカナ文字列の正規表現
 */
const KATAKANA_REGEX = /^[ァ-ヶー\s]+$/;

/**
 * 電話番号の正規表現 (数字とハイフンのみ)
 */
const PHONE_REGEX = /^[0-9-]+$/;

/**
 * 顧客登録・更新用スキーマ
 */
export const customerSchema = z.object({
  customerName: z
    .string({ required_error: '顧客名を入力してください' })
    .min(1, '顧客名を入力してください')
    .max(100, '顧客名は100文字以内で入力してください'),

  customerNameKana: z
    .string({ required_error: '顧客名カナを入力してください' })
    .min(1, '顧客名カナを入力してください')
    .max(100, '顧客名カナは100文字以内で入力してください')
    .regex(KATAKANA_REGEX, '顧客名カナは全角カタカナで入力してください'),

  phoneNumber: z
    .string({ required_error: '電話番号を入力してください' })
    .min(1, '電話番号を入力してください')
    .max(15, '電話番号は15文字以内で入力してください')
    .regex(PHONE_REGEX, '電話番号の形式が正しくありません'),

  email: z
    .string({ required_error: 'メールアドレスを入力してください' })
    .min(1, 'メールアドレスを入力してください')
    .email('メールアドレスの形式が正しくありません')
    .max(256, 'メールアドレスは256文字以内で入力してください'),

  address: z
    .string({ required_error: '住所を入力してください' })
    .min(1, '住所を入力してください')
    .max(500, '住所は500文字以内で入力してください'),

  birthDate: z
    .string()
    .optional()
    .refine(
      (val) => {
        if (!val) return true;
        const date = new Date(val);
        const minDate = new Date('1900-01-01');
        const maxDate = new Date();
        return date >= minDate && date <= maxDate;
      },
      { message: '生年月日は1900-01-01から現在日までの範囲で入力してください' }
    ),

  notes: z
    .string()
    .max(1000, '備考は1000文字以内で入力してください')
    .optional(),
});

export type CustomerInput = z.infer<typeof customerSchema>;

/**
 * 顧客更新用スキーマ (バージョン情報を含む)
 */
export const customerUpdateSchema = customerSchema.extend({
  version: z.number({ required_error: 'バージョン情報が必要です' }),
});

export type CustomerUpdateInput = z.infer<typeof customerUpdateSchema>;
```

### Zodエラー変換ユーティリティ

```typescript
// lib/api/utils/validation.ts

import { ZodError } from 'zod';
import { ValidationError } from '../errors';

/**
 * ZodエラーをAPIエラー形式に変換
 */
export function formatZodError(error: ZodError): ValidationError {
  const details: Record<string, string[]> = {};

  error.errors.forEach((err) => {
    const field = err.path.join('.');
    const message = err.message;

    if (!details[field]) {
      details[field] = [];
    }
    details[field].push(message);
  });

  return new ValidationError(details);
}

/**
 * Zodスキーマでバリデーションを実行し、エラーを変換
 */
export function validateWithZod<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof ZodError) {
      throw formatZodError(error);
    }
    throw error;
  }
}

/**
 * 非同期バージョン
 */
export async function validateWithZodAsync<T>(
  schema: z.ZodSchema<T>,
  data: unknown
): Promise<T> {
  try {
    return await schema.parseAsync(data);
  } catch (error) {
    if (error instanceof ZodError) {
      throw formatZodError(error);
    }
    throw error;
  }
}
```

---

## ビジネスエラー

### データ未存在エラー

```typescript
// app/api/customers/[id]/route.ts での使用例

import { CustomerNotFoundError } from '@/lib/api/errors';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const customer = await prisma.customer.findUnique({
    where: { id: params.id },
  });

  if (!customer) {
    throw new CustomerNotFoundError(params.id);
  }

  return Response.json(customer);
}
```

### 重複エラー

```typescript
// app/api/customers/route.ts での使用例

import { DuplicateError } from '@/lib/api/errors';
import { Prisma } from '@prisma/client';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const validatedData = validateWithZod(customerSchema, body);

    const customer = await prisma.customer.create({
      data: validatedData,
    });

    return Response.json(customer, { status: 201 });

  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // P2002: 一意制約違反
      if (error.code === 'P2002') {
        const field = (error.meta?.target as string[])?.[0] || 'unknown';
        throw new DuplicateError(field);
      }
    }
    throw error;
  }
}
```

### 楽観的排他制御エラー

```typescript
// app/api/customers/[id]/route.ts での使用例

import { OptimisticLockError } from '@/lib/api/errors';

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  const body = await request.json();
  const validatedData = validateWithZod(customerUpdateSchema, body);

  try {
    const customer = await prisma.customer.update({
      where: {
        id: params.id,
        version: validatedData.version, // 楽観的ロック
      },
      data: {
        ...validatedData,
        version: { increment: 1 },
      },
    });

    return Response.json(customer);

  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      // P2025: レコードが見つからない (バージョン不一致)
      if (error.code === 'P2025') {
        throw new OptimisticLockError();
      }
    }
    throw error;
  }
}
```

---

## エラーハンドリング実装

### グローバルエラーハンドラー

```typescript
// lib/api/middleware/error-handler.ts

import { NextResponse } from 'next/server';
import { ApiError, InternalServerError } from '../errors';
import { ZodError } from 'zod';
import { formatZodError } from '../utils/validation';

/**
 * APIエラーハンドラーミドルウェア
 *
 * Next.js API Routeでの使用例:
 * ```typescript
 * export async function GET(request: Request) {
 *   return withErrorHandler(async () => {
 *     // API処理
 *   });
 * }
 * ```
 */
export async function withErrorHandler<T>(
  handler: () => Promise<Response> | Response
): Promise<Response> {
  try {
    return await handler();
  } catch (error) {
    return handleError(error);
  }
}

/**
 * エラーをAPIレスポンスに変換
 */
function handleError(error: unknown): Response {
  // ApiErrorの場合はそのまま返却
  if (error instanceof ApiError) {
    return NextResponse.json(
      error.toResponse(),
      { status: error.status }
    );
  }

  // ZodErrorの場合は変換
  if (error instanceof ZodError) {
    const apiError = formatZodError(error);
    return NextResponse.json(
      apiError.toResponse(),
      { status: apiError.status }
    );
  }

  // その他のエラーは500エラーとして処理
  console.error('Unexpected error:', error);

  const internalError = new InternalServerError();
  return NextResponse.json(
    internalError.toResponse(),
    { status: 500 }
  );
}
```

### API Route実装例

```typescript
// app/api/customers/route.ts

import { NextRequest } from 'next/server';
import { withErrorHandler } from '@/lib/api/middleware/error-handler';
import { validateWithZod } from '@/lib/api/utils/validation';
import { customerSchema } from '@/lib/validations/customer';
import { DuplicateError, InternalServerError } from '@/lib/api/errors';
import { prisma } from '@/lib/prisma';
import { Prisma } from '@prisma/client';

/**
 * 顧客一覧取得
 */
export async function GET(request: NextRequest) {
  return withErrorHandler(async () => {
    const searchParams = request.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const skip = (page - 1) * limit;

    const [customers, total] = await prisma.$transaction([
      prisma.customer.findMany({
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      prisma.customer.count(),
    ]);

    return Response.json({
      customers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  });
}

/**
 * 顧客登録
 */
export async function POST(request: Request) {
  return withErrorHandler(async () => {
    const body = await request.json();
    const validatedData = validateWithZod(customerSchema, body);

    try {
      const customer = await prisma.customer.create({
        data: {
          ...validatedData,
          version: 1,
        },
      });

      return Response.json(customer, { status: 201 });

    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          const field = (error.meta?.target as string[])?.[0] || 'unknown';
          throw new DuplicateError(field);
        }
      }
      throw new InternalServerError('顧客の登録に失敗しました', error as Error);
    }
  });
}
```

```typescript
// app/api/customers/[id]/route.ts

import { NextRequest } from 'next/server';
import { withErrorHandler } from '@/lib/api/middleware/error-handler';
import { validateWithZod } from '@/lib/api/utils/validation';
import { customerUpdateSchema } from '@/lib/validations/customer';
import {
  CustomerNotFoundError,
  OptimisticLockError,
  DuplicateError,
  InternalServerError,
} from '@/lib/api/errors';
import { prisma } from '@/lib/prisma';
import { Prisma } from '@prisma/client';

/**
 * 顧客詳細取得
 */
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  return withErrorHandler(async () => {
    const customer = await prisma.customer.findUnique({
      where: { id: params.id },
    });

    if (!customer) {
      throw new CustomerNotFoundError(params.id);
    }

    return Response.json(customer);
  });
}

/**
 * 顧客更新
 */
export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  return withErrorHandler(async () => {
    const body = await request.json();
    const validatedData = validateWithZod(customerUpdateSchema, body);

    try {
      const customer = await prisma.customer.update({
        where: {
          id: params.id,
          version: validatedData.version,
        },
        data: {
          ...validatedData,
          version: { increment: 1 },
          updatedAt: new Date(),
        },
      });

      return Response.json(customer);

    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        // P2025: レコードが見つからない
        if (error.code === 'P2025') {
          // バージョン不一致または存在しないデータ
          const existing = await prisma.customer.findUnique({
            where: { id: params.id },
          });

          if (!existing) {
            throw new CustomerNotFoundError(params.id);
          } else {
            throw new OptimisticLockError();
          }
        }
        // P2002: 一意制約違反
        if (error.code === 'P2002') {
          const field = (error.meta?.target as string[])?.[0] || 'unknown';
          throw new DuplicateError(field);
        }
      }
      throw new InternalServerError('顧客の更新に失敗しました', error as Error);
    }
  });
}

/**
 * 顧客削除
 */
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  return withErrorHandler(async () => {
    try {
      await prisma.customer.delete({
        where: { id: params.id },
      });

      return new Response(null, { status: 204 });

    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
          throw new CustomerNotFoundError(params.id);
        }
      }
      throw new InternalServerError('顧客の削除に失敗しました', error as Error);
    }
  });
}
```

---

## メッセージ定義

### バリデーションエラーメッセージ一覧

| フィールド | エラー種別 | メッセージ |
|----------|----------|----------|
| customerName | 必須 | 顧客名を入力してください |
| customerName | 最大長 | 顧客名は100文字以内で入力してください |
| customerNameKana | 必須 | 顧客名カナを入力してください |
| customerNameKana | 形式 | 顧客名カナは全角カタカナで入力してください |
| customerNameKana | 最大長 | 顧客名カナは100文字以内で入力してください |
| phoneNumber | 必須 | 電話番号を入力してください |
| phoneNumber | 形式 | 電話番号の形式が正しくありません |
| phoneNumber | 最大長 | 電話番号は15文字以内で入力してください |
| email | 必須 | メールアドレスを入力してください |
| email | 形式 | メールアドレスの形式が正しくありません |
| email | 最大長 | メールアドレスは256文字以内で入力してください |
| address | 必須 | 住所を入力してください |
| address | 最大長 | 住所は500文字以内で入力してください |
| birthDate | 範囲 | 生年月日は1900-01-01から現在日までの範囲で入力してください |
| notes | 最大長 | 備考は1000文字以内で入力してください |

### ビジネスエラーメッセージ一覧

| エラーコード | HTTPステータス | メッセージ | 発生条件 |
|------------|--------------|----------|---------|
| FB1999901 | 404 | 指定された顧客情報が見つかりません | 顧客IDが存在しない |
| FB1999901 | 404 | 顧客ID {id} が見つかりません | 顧客IDが存在しない (ID付き) |
| FB1999902 | 400 | 入力値が正しくありません | バリデーションエラー |
| FB1999903 | 401 | 認証が必要です | 未認証アクセス |
| FB1999904 | 403 | この操作を実行する権限がありません | 権限不足 |
| FB1999905 | 409 | データが他のユーザーによって更新されています。最新のデータを取得し直してください | バージョン不一致 |
| FB1999906 | 409 | このメールアドレスは既に登録されています | メール重複 |
| FB1999906 | 409 | この電話番号は既に登録されています | 電話番号重複 |
| FB1999999 | 500 | システムエラーが発生しました。管理者に連絡してください | 予期しないエラー |

### エラーレスポンス例

#### 1. バリデーションエラー (複数フィールド)

**リクエスト:**
```json
POST /api/customers
{
  "customerName": "",
  "customerNameKana": "山田太郎",
  "phoneNumber": "090-1234-567890",
  "email": "invalid-email",
  "address": "東京都"
}
```

**レスポンス (400):**
```json
{
  "code": "FB1999902",
  "message": "入力値が正しくありません",
  "details": {
    "customerName": [
      "顧客名を入力してください"
    ],
    "customerNameKana": [
      "顧客名カナは全角カタカナで入力してください"
    ],
    "phoneNumber": [
      "電話番号は15文字以内で入力してください"
    ],
    "email": [
      "メールアドレスの形式が正しくありません"
    ]
  },
  "timestamp": "2025-11-27T12:34:56.789Z"
}
```

#### 2. 顧客未存在エラー

**リクエスト:**
```
GET /api/customers/abc123
```

**レスポンス (404):**
```json
{
  "code": "FB1999901",
  "message": "顧客ID abc123 が見つかりません",
  "timestamp": "2025-11-27T12:34:56.789Z"
}
```

#### 3. 重複エラー

**リクエスト:**
```json
POST /api/customers
{
  "customerName": "山田太郎",
  "customerNameKana": "ヤマダタロウ",
  "phoneNumber": "090-1234-5678",
  "email": "existing@example.com",
  "address": "東京都渋谷区"
}
```

**レスポンス (409):**
```json
{
  "code": "FB1999906",
  "message": "このメールアドレスは既に登録されています",
  "details": {
    "email": [
      "このメールアドレスは既に登録されています"
    ]
  },
  "timestamp": "2025-11-27T12:34:56.789Z"
}
```

#### 4. 楽観的排他エラー

**リクエスト:**
```json
PUT /api/customers/abc123
{
  "customerName": "山田太郎",
  "customerNameKana": "ヤマダタロウ",
  "phoneNumber": "090-1234-5678",
  "email": "yamada@example.com",
  "address": "東京都渋谷区",
  "version": 1
}
```

**レスポンス (409):**
```json
{
  "code": "FB1999905",
  "message": "データが他のユーザーによって更新されています。最新のデータを取得し直してください",
  "timestamp": "2025-11-27T12:34:56.789Z"
}
```

#### 5. システムエラー

**レスポンス (500):**
```json
{
  "code": "FB1999999",
  "message": "システムエラーが発生しました。管理者に連絡してください",
  "timestamp": "2025-11-27T12:34:56.789Z"
}
```

---

## フロントエンド統合

### エラー型定義 (クライアント側)

```typescript
// types/api.ts

export type ApiErrorResponse = {
  code: string;
  message: string;
  details?: Record<string, string[]>;
  timestamp?: string;
};

export class ApiError extends Error {
  constructor(
    public code: string,
    message: string,
    public status: number,
    public details?: Record<string, string[]>
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
```

### APIクライアント実装例

```typescript
// lib/api-client.ts

import type { ApiErrorResponse } from '@/types/api';
import { ApiError } from '@/types/api';

/**
 * APIリクエスト実行
 */
export async function apiRequest<T>(
  url: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    ...options,
  });

  if (!response.ok) {
    const error: ApiErrorResponse = await response.json();
    throw new ApiError(
      error.code,
      error.message,
      response.status,
      error.details
    );
  }

  // 204 No Content の場合
  if (response.status === 204) {
    return undefined as T;
  }

  return response.json();
}

/**
 * 顧客API
 */
export const customerApi = {
  async getAll(page = 1, limit = 10) {
    return apiRequest<{ customers: Customer[]; pagination: Pagination }>(
      `/api/customers?page=${page}&limit=${limit}`
    );
  },

  async getById(id: string) {
    return apiRequest<Customer>(`/api/customers/${id}`);
  },

  async create(data: CustomerInput) {
    return apiRequest<Customer>('/api/customers', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  async update(id: string, data: CustomerUpdateInput) {
    return apiRequest<Customer>(`/api/customers/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  async delete(id: string) {
    return apiRequest<void>(`/api/customers/${id}`, {
      method: 'DELETE',
    });
  },
};
```

### React フォームでのエラー処理例

```typescript
// components/customer-form.tsx

'use client';

import { useState } from 'react';
import { customerApi } from '@/lib/api-client';
import { ApiError } from '@/types/api';
import type { CustomerInput } from '@/lib/validations/customer';

export function CustomerForm() {
  const [errors, setErrors] = useState<Record<string, string[]>>({});
  const [generalError, setGeneralError] = useState<string>('');

  const handleSubmit = async (data: CustomerInput) => {
    try {
      setErrors({});
      setGeneralError('');

      await customerApi.create(data);
      // 成功処理

    } catch (error) {
      if (error instanceof ApiError) {
        // バリデーションエラー
        if (error.code === 'FB1999902' && error.details) {
          setErrors(error.details);
        }
        // その他のエラー
        else {
          setGeneralError(error.message);
        }
      } else {
        setGeneralError('予期しないエラーが発生しました');
      }
    }
  };

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      // フォームデータ収集
      handleSubmit(formData);
    }}>
      {generalError && (
        <div className="error-message">{generalError}</div>
      )}

      <div>
        <label>顧客名</label>
        <input name="customerName" />
        {errors.customerName?.map((msg, i) => (
          <span key={i} className="field-error">{msg}</span>
        ))}
      </div>

      {/* 他のフィールド */}
    </form>
  );
}
```

---

## 国際化対応 (将来対応)

### メッセージ外部化の準備

```typescript
// lib/i18n/messages.ts

/**
 * エラーメッセージ定義 (将来的にi18nライブラリと統合)
 */
export const errorMessages = {
  ja: {
    validation: {
      required: {
        customerName: '顧客名を入力してください',
        customerNameKana: '顧客名カナを入力してください',
        phoneNumber: '電話番号を入力してください',
        email: 'メールアドレスを入力してください',
        address: '住所を入力してください',
      },
      format: {
        customerNameKana: '顧客名カナは全角カタカナで入力してください',
        phoneNumber: '電話番号の形式が正しくありません',
        email: 'メールアドレスの形式が正しくありません',
        birthDate: '生年月日の形式が正しくありません(YYYY-MM-DD)',
      },
      maxLength: {
        customerName: '顧客名は100文字以内で入力してください',
        customerNameKana: '顧客名カナは100文字以内で入力してください',
        phoneNumber: '電話番号は15文字以内で入力してください',
        email: 'メールアドレスは256文字以内で入力してください',
        address: '住所は500文字以内で入力してください',
        notes: '備考は1000文字以内で入力してください',
      },
      range: {
        birthDate: '生年月日は1900-01-01から現在日までの範囲で入力してください',
      },
    },
    business: {
      notFound: '指定された顧客情報が見つかりません',
      notFoundWithId: '顧客ID {id} が見つかりません',
      duplicate: {
        email: 'このメールアドレスは既に登録されています',
        phoneNumber: 'この電話番号は既に登録されています',
      },
      optimisticLock: 'データが他のユーザーによって更新されています。最新のデータを取得し直してください',
    },
    system: {
      internalError: 'システムエラーが発生しました。管理者に連絡してください',
      unauthorized: '認証が必要です',
      forbidden: 'この操作を実行する権限がありません',
    },
  },
  en: {
    // 英語メッセージ (将来対応)
  },
} as const;
```

---

## テスト実装例

### エラーハンドリングのユニットテスト

```typescript
// __tests__/lib/api/errors.test.ts

import { describe, it, expect } from 'vitest';
import {
  ApiError,
  CustomerNotFoundError,
  ValidationError,
  OptimisticLockError,
  DuplicateError,
} from '@/lib/api/errors';
import { ErrorCode } from '@/lib/api/error-codes';

describe('ApiError', () => {
  it('should create error with correct properties', () => {
    const error = new ApiError(
      ErrorCode.VALIDATION_ERROR,
      'Test error',
      { field: ['error message'] }
    );

    expect(error.code).toBe(ErrorCode.VALIDATION_ERROR);
    expect(error.message).toBe('Test error');
    expect(error.status).toBe(400);
    expect(error.details).toEqual({ field: ['error message'] });
  });

  it('should convert to response object', () => {
    const error = new ApiError(
      ErrorCode.NOT_FOUND,
      'Not found'
    );

    const response = error.toResponse();

    expect(response.code).toBe(ErrorCode.NOT_FOUND);
    expect(response.message).toBe('Not found');
    expect(response.timestamp).toBeDefined();
  });
});

describe('CustomerNotFoundError', () => {
  it('should create error with customer ID', () => {
    const error = new CustomerNotFoundError('abc123');

    expect(error.code).toBe(ErrorCode.NOT_FOUND);
    expect(error.message).toContain('abc123');
    expect(error.status).toBe(404);
  });

  it('should create error without customer ID', () => {
    const error = new CustomerNotFoundError();

    expect(error.message).toBe('指定された顧客情報が見つかりません');
  });
});

describe('ValidationError', () => {
  it('should create validation error with details', () => {
    const details = {
      email: ['メールアドレスの形式が正しくありません'],
      phoneNumber: ['電話番号は15文字以内で入力してください'],
    };

    const error = new ValidationError(details);

    expect(error.code).toBe(ErrorCode.VALIDATION_ERROR);
    expect(error.status).toBe(400);
    expect(error.details).toEqual(details);
  });
});
```

### API Routeの統合テスト

```typescript
// __tests__/app/api/customers/route.test.ts

import { describe, it, expect, beforeEach } from 'vitest';
import { POST, GET } from '@/app/api/customers/route';
import { prisma } from '@/lib/prisma';

describe('POST /api/customers', () => {
  beforeEach(async () => {
    await prisma.customer.deleteMany();
  });

  it('should create customer with valid data', async () => {
    const request = new Request('http://localhost/api/customers', {
      method: 'POST',
      body: JSON.stringify({
        customerName: '山田太郎',
        customerNameKana: 'ヤマダタロウ',
        phoneNumber: '090-1234-5678',
        email: 'yamada@example.com',
        address: '東京都渋谷区',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.customerName).toBe('山田太郎');
  });

  it('should return validation error for invalid data', async () => {
    const request = new Request('http://localhost/api/customers', {
      method: 'POST',
      body: JSON.stringify({
        customerName: '',
        email: 'invalid-email',
      }),
    });

    const response = await POST(request);
    const error = await response.json();

    expect(response.status).toBe(400);
    expect(error.code).toBe('FB1999902');
    expect(error.details).toBeDefined();
  });

  it('should return duplicate error for existing email', async () => {
    // 既存データ作成
    await prisma.customer.create({
      data: {
        customerName: '既存顧客',
        customerNameKana: 'キゾンコキャク',
        phoneNumber: '090-0000-0000',
        email: 'existing@example.com',
        address: '東京都',
        version: 1,
      },
    });

    const request = new Request('http://localhost/api/customers', {
      method: 'POST',
      body: JSON.stringify({
        customerName: '新規顧客',
        customerNameKana: 'シンキコキャク',
        phoneNumber: '090-1111-1111',
        email: 'existing@example.com', // 重複
        address: '東京都',
      }),
    });

    const response = await POST(request);
    const error = await response.json();

    expect(response.status).toBe(409);
    expect(error.code).toBe('FB1999906');
    expect(error.message).toContain('メールアドレス');
  });
});
```

---

## 改訂履歴

| バージョン | 改訂日 | 改訂内容 | 改訂者 |
|----------|--------|---------|--------|
| 1.0 | 2025-11-27 | 初版作成 (Spring Boot版) | - |
| 2.0 | 2025-11-27 | Next.js版へ全面改訂 | - |

### 主な変更点 (v2.0)

- Next.js App RouterのAPI Routes対応
- TypeScript型安全なエラー処理実装
- Zodバリデーション統合
- Prismaエラーハンドリング対応
- エラーコード体系の見直し (FB1999901〜FB1999907)
- フロントエンド統合パターンの追加
- ユニットテスト・統合テストの実装例追加
